const questionsData = [
        {
            "id": 1,
            "questionEn": "1. Is Java Platform Independent if then how?",
            "answerEn": "Java is platform-independent through its \"Write Once, Run Anywhere\" approach. The javac compiler transforms code into bytecode, a .class file that works across different systems. This bytecode executes on any platform with a preinstalled JVM, despite hardware or software variations. The JVM, though platform-specific, enables this portability by interpreting the bytecode. This design ensures Java’s flexibility across diverse environments.",
            "questionRu": "Является ли Java платформонезависимой? Если да, то как?",
            "answerRu": "Java платформонезависима благодаря принципу \"пиши один раз, запускай везде\". Компилятор javac преобразует код в байт-код, файл .class, который работает на разных системах. Этот байт-код выполняется на любой платформе с предустановленной JVM, независимо от оборудования или ПО. JVM, будучи платформозависимой, обеспечивает переносимость, интерпретируя байт-код. Такой подход гарантирует гибкость Java в разных средах.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 2,
            "questionEn": "What are the top Java Features?",
            "answerEn": "Java features a simple syntax for easy learning and coding. It is platform-independent, running the same bytecode on any system with a JVM. The language is object-oriented, supporting classes, objects, and the four pillars of OOP (encapsulation, inheritance, polymorphism, abstraction). Robustness and security are ensured by garbage collection, exception handling, and bytecode protection. Multithreading, high performance via JIT compilation, and distributed computing enhance its versatility.",
            "questionRu": "Какие основные особенности Java?",
            "answerRu": "Java имеет простой синтаксис для легкого изучения и написания кода. Она платформонезависима, позволяя запускать один байт-код на любой системе с JVM. Язык объектно-ориентирован, поддерживая классы, объекты и четыре принципа ООП (инкапсуляция, наследование, полиморфизм, абстракция). Надежность и безопасность обеспечиваются сборкой мусора, обработкой исключений и защитой байт-кода. Многопоточность, высокая производительность через JIT-компиляцию и распределенные вычисления увеличивают её универсальность.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 3,
            "questionEn": "What is JVM?",
            "answerEn": "JVM stands for Java Virtual Machine, acting as an interpreter for Java bytecode. It loads, verifies, and executes the bytecode generated by the javac compiler. The JVM is platform-dependent, with specific versions for different operating systems. Despite this, it enables Java’s platform independence by running the same bytecode across various systems. This makes JVM a critical component of Java’s architecture.",
            "questionRu": "Что такое JVM?",
            "answerRu": "JVM расшифровывается как Java Virtual Machine и служит интерпретатором байт-кода Java. Она загружает, проверяет и выполняет байт-код, сгенерированный компилятором javac. JVM платформозависима, с различными версиями для разных операционных систем. Тем не менее, она обеспечивает платформонезависимость Java, запуская один и тот же байт-код на разных системах. Это делает JVM ключевым элементом архитектуры Java.",
            "category": "JVM Memory Management & Garbage Collection",
            "level": "Junior"
        },
        {
            "id": 4,
            "questionEn": "What is JIT?",
            "answerEn": "JIT stands for Just-in-Time compiler, a component of the JRE that enhances Java application performance. It compiles bytecode into native machine code at runtime, triggered when a method is invoked. The JVM then executes the compiled code directly, bypassing interpretation for improved speed. This process begins with javac compiling source code into bytecode, which JIT optimizes. JIT significantly boosts execution efficiency in Java applications.",
            "questionRu": "Что такое JIT?",
            "answerRu": "JIT расшифровывается как Just-in-Time компилятор, компонент JRE, улучшающий производительность Java-приложений. Он компилирует байт-код в нативный машинный код во время выполнения, активируясь при вызове метода. JVM затем выполняет скомпилированный код напрямую, обходя интерпретацию для повышения скорости. Процесс начинается с компиляции исходного кода в байт-код через javac, который JIT оптимизирует. JIT существенно увеличивает эффективность выполнения Java-приложений.",
            "category": "JVM Memory Management & Garbage Collection",
            "level": "Junior"
        },
        {
            "id": 5,
            "questionEn": "What are Memory storages available with JVM?",
            "answerEn": "JVM provides several memory areas for efficient execution. The Class (Method) Area stores class-level data, including runtime constant pools and method code. The Heap allocates memory for objects during runtime. The Stack manages method call data and partial results, while the Program Counter Register tracks the current JVM instruction address. The Native Method Stack handles memory for native method calls.",
            "questionRu": "Какие области памяти доступны в JVM?",
            "answerRu": "JVM использует несколько областей памяти для эффективного выполнения. Область Class (Method) хранит данные класса, включая пул постоянных значений и код методов. Heap выделяет память для объектов во время выполнения. Stack управляет данными вызовов методов и промежуточными результатами, а Program Counter Register отслеживает адрес текущей инструкции JVM. Native Method Stack обрабатывает память для нативных вызовов методов.",
            "category": "JVM Memory Management & Garbage Collection",
            "level": "Junior"
        },
        {
            "id": 6,
            "questionEn": "What is a Classloader?",
            "answerEn": "Classloader, a component of the JRE, dynamically loads Java classes and interfaces into the JVM during runtime. It reads the bytecode from .class files and integrates it into the JVM for execution. Classloaders operate in a hierarchical structure, with types like Bootstrap, Extension, and Application Classloaders. This mechanism abstracts file system details, simplifying Java’s runtime environment. Classloaders ensure flexibility by loading classes only when needed.",
            "questionRu": "Что такое Classloader?",
            "answerRu": "Classloader, часть JRE, динамически загружает классы и интерфейсы Java в JVM во время выполнения. Он считывает байт-код из .class файлов и интегрирует его в JVM для выполнения. Classloaders работают в иерархической структуре, включая типы Bootstrap, Extension и Application Classloaders. Этот механизм скрывает детали файловой системы, упрощая среду выполнения Java. Classloaders обеспечивают гибкость, загружая классы только по мере необходимости.",
            "category": "JVM Memory Management & Garbage Collection",
            "level": "Junior"
        },
        {
            "id": 7,
            "questionEn": "What are the differences between JVM, JRE, and JDK?",
            "answerEn": "Java Virtual Machine, interprets bytecode into machine-readable code and is platform-dependent, yet enables Java’s platform independence. JRE, or Java Runtime Environment, provides the runtime environment to execute Java applications, including the JVM and core libraries. JDK, or Java Development Kit, includes the JRE plus development tools like javac for coding and debugging. The JVM executes bytecode, JRE supports runtime, and JDK facilitates both development and execution. This structure ensures Java’s versatility across development and deployment.",
            "questionRu": "Чем отличаются JVM, JRE и JDK?",
            "answerRu": "Java Virtual Machine, интерпретирует байт-код в машинный код и зависит от платформы, но обеспечивает платформонезависимость Java. JRE, или Java Runtime Environment, предоставляет среду выполнения для Java-приложений, включая JVM и базовые библиотеки. JDK, или Java Development Kit, содержит JRE и инструменты разработки, такие как javac, для написания и отладки кода. JVM выполняет байт-код, JRE поддерживает выполнение, а JDK позволяет разрабатывать и запускать программы. Эта структура делает Java универсальной для разработки и развертывания.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 8,
            "questionEn": "What are the differences between Java and C++?",
            "answerEn": "Java is platform-independent due to its JVM, while C++ is platform-dependent, requiring recompilation for each system. Java primarily supports application programming with a single inheritance tree rooted at java.lang.Object, whereas C++ is used for system programming and supports multiple inheritance. C++ interacts closely with hardware and allows pointers and call-by-reference, which Java avoids for safety. Java offers thread support and documentation comments, unlike C++. Both are object-oriented, but C++ supports global scope and features like goto, which Java excludes.",
            "questionRu": "Чем отличаются Java и C++?",
            "answerRu": "Java платформонезависима благодаря JVM, тогда как C++ платформозависим и требует перекомпиляции для каждой системы. Java в основном используется для прикладного программирования с единым деревом наследования от java.lang.Object, а C++ — для системного программирования с поддержкой множественного наследования. C++ тесно взаимодействует с оборудованием и позволяет использовать указатели и вызовы по ссылке, чего Java избегает ради безопасности. Java поддерживает потоки и комментарии документации, в отличие от C++. Оба языка объектно-ориентированы, но C++ поддерживает глобальную область видимости и функции вроде goto, которых нет в Java.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 9,
            "questionEn": "Explain public static void main(String args[]) in Java.",
            "answerEn": "The public static void main(String args[]) method is the entry point for any Java application. The public modifier makes it accessible to the JVM from outside the class. The static keyword allows the JVM to call it without creating an instance of the class, saving memory. The void return type indicates that the method does not return any value, and main is the standard name recognized by the JVM. The String args[] parameter accepts command-line arguments as an array of strings.",
            "questionRu": "Объясните public static void main(String args[]) в Java.",
            "answerRu": "Метод public static void main(String args[]) — точка входа для любого Java-приложения. Модификатор public делает его доступным для JVM извне класса. Ключевое слово static позволяет JVM вызывать его без создания экземпляра класса, экономя память. Тип возврата void указывает, что метод ничего не возвращает, а main — стандартное имя, распознаваемое JVM. Параметр String args[] принимает аргументы командной строки в виде массива строк.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 10,
            "questionEn": "What is Java String Pool?",
            "answerEn": "The Java String Pool is a special area in heap memory that stores string literals. When a string is created, the JVM checks if it exists in the pool. If it does, the existing reference is reused; otherwise, a new string object is added to the pool. String variables, however, are stored in the stack, pointing to the pooled string. This mechanism optimizes memory usage by avoiding duplicate string objects.",
            "questionRu": "Что такое Java String Pool?",
            "answerRu": "Java String Pool — это специальная область в куче (heap), где хранятся строковые литералы. При создании строки JVM проверяет её наличие в пуле. Если строка уже есть, используется существующая ссылка; если нет, создаётся новый объект в пуле. Переменные строк хранятся в стеке и указывают на строку в пуле. Этот механизм оптимизирует использование памяти, избегая дублирования строк.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 11,
            "questionEn": "What will happen if we don’t declare main as static?",
            "answerEn": "We can declare the main method without using static and without getting any errors. But, the main method will not be treated as the entry point to the application or the program.",
            "questionRu": "Что произойдет, если не объявить main как static?",
            "answerRu": "Мы можем объявить метод main без использования static без ошибок. Однако он не будет считаться точкой входа в приложение или программу.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 12,
            "questionEn": "What are Packages in Java?",
            "answerEn": "Packages in Java group related classes, interfaces, and sub-packages for better organization. They provide access control by defining visibility scopes, such as public or protected. Packages also manage namespaces, preventing naming conflicts between classes. For example, java.util includes utility classes like ArrayList. This structure enhances code modularity and reusability.",
            "questionRu": "Что такое пакеты в Java?",
            "answerRu": "Пакеты в Java группируют связанные классы, интерфейсы и подпакеты для лучшей организации. Они обеспечивают контроль доступа, определяя области видимости, такие как public или protected. Пакеты также управляют пространствами имен, предотвращая конфликты имен между классами. Например, java.util содержит утилитные классы, такие как ArrayList. Эта структура повышает модульность и повторное использование кода.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 13,
            "questionEn": "Why are Packages used?",
            "answerEn": "Packages in Java prevent naming conflicts by organizing classes and interfaces into unique namespaces. They control access through visibility modifiers like public or protected, restricting unauthorized use. Packages simplify searching and usage, as related classes are grouped, such as java.util for utilities. They also improve code maintainability by promoting modularity. This organization enhances development efficiency and scalability.",
            "questionRu": "Зачем нужны пакеты в Java?",
            "answerRu": "Пакеты в Java предотвращают конфликты имен, организуя классы и интерфейсы в уникальные пространства имен. Они управляют доступом через модификаторы видимости, такие как public или protected, ограничивая несанкционированное использование. Пакеты упрощают поиск и использование, группируя связанные классы, например java.util для утилит. Они также улучшают поддержку кода за счет модульности. Такая организация повышает эффективность разработки и масштабируемость.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 14,
            "questionEn": "What are the advantages of Packages in Java?",
            "answerEn": "Packages avoid name clashes. The Package provides easier access control. We can also have the hidden classes that are not visible outside and are used by the package. It is easier to locate the related classes.",
            "questionRu": "Какие преимущества пакетов в Java?",
            "answerRu": "Пакеты предотвращают конфликты имен. Они обеспечивают более простой контроль доступа. Также можно иметь скрытые классы, невидимые извне и используемые внутри пакета. Легче находить связанные классы.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 15,
            "questionEn": "How many types of packages are there in Java?",
            "answerEn": "Java has two types of packages: built-in and user-defined. Built-in packages, like java.util and java.lang, are part of the Java API and provide standard functionality. User-defined packages are created by developers to organize custom classes and interfaces. They help manage code structure and avoid naming conflicts. Both types enhance modularity in Java applications.",
            "questionRu": "Сколько типов пакетов в Java?",
            "answerRu": "В Java существует два типа пакетов: встроенные и пользовательские. Встроенные пакеты, такие как java.util и java.lang, входят в состав Java API и предоставляют стандартные функции. Пользовательские пакеты создаются разработчиками для организации собственных классов и интерфейсов. Они помогают структурировать код и избегать конфликтов имен. Оба типа повышают модульность приложений на Java.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 16,
            "questionEn": "Explain different data types in Java.",
            "answerEn": "Java data types are divided into primitive and non-primitive types. Primitive types, such as int, float, and boolean, store single values directly in memory. Non-primitive types, also called reference types, include classes, interfaces, arrays, and strings, storing memory addresses rather than values. Primitive types are predefined with fixed sizes, while non-primitive types are user-defined or part of the Java API. This distinction allows Java to handle both simple and complex data efficiently.",
            "questionRu": "Объясните разные типы данных в Java.",
            "answerRu": "Типы данных в Java делятся на примитивные и непримитивные. Примитивные типы, такие как int, float и boolean, хранят одиночные значения напрямую в памяти. Непримитивные типы, или ссылочные, включают классы, интерфейсы, массивы и строки, храня адреса памяти, а не сами значения. Примитивные типы предопределены с фиксированными размерами, тогда как непримитивные создаются пользователем или входят в Java API. Это разделение позволяет Java эффективно работать с простыми и сложными данными.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 17,
            "questionEn": "When is a byte datatype used?",
            "answerEn": "A byte is an 8-bit signed two-complement integer. The minimum value supported by bytes is -128 and 127 is the maximum value. It is used in conditions where we need to save memory and the limit of numbers needed is between -128 to 127.",
            "questionRu": "Когда используется тип данных byte?",
            "answerRu": "Byte — это 8-битное знаковое целое число в дополнительном коде. Поддерживаемые значения находятся в диапазоне от -128 до 127. Оно используется, когда нужно экономить память и диапазон чисел укладывается между -128 и 127.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 18,
            "questionEn": "Can we declare Pointers in Java?",
            "answerEn": "No, Java does not support pointers to enhance security and simplify memory management. This design prevents direct memory access, reducing risks like buffer overflows common in languages like C++. Instead, Java uses references to objects, managed automatically by the JVM. The absence of pointers aligns with Java’s goal of platform independence and reliability.",
            "questionRu": "Можно ли объявить указатели в Java?",
            "answerRu": "Нет, Java не поддерживает указатели для повышения безопасности и упрощения управления памятью. Такой подход исключает прямой доступ к памяти, снижая риски, такие как переполнение буфера, характерное для языков вроде C++. Вместо этого Java использует ссылки на объекты, управляемые JVM автоматически. Отсутствие указателей соответствует цели Java — платформонезависимости и надежности.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 19,
            "questionEn": "What is the default value of byte datatype in Java?",
            "answerEn": "The default value of the byte datatype in Java is 0.",
            "questionRu": "Какое значение по умолчанию у типа byte в Java?",
            "answerRu": "Значение по умолчанию для типа данных byte в Java — 0.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 20,
            "questionEn": "What is the default value of float and double datatype in Java?",
            "answerEn": "The default value of the float datatype in Java is 0.0f, and for double, it is 0.0d. Float is a 32-bit single-precision floating-point type, while double is a 64-bit double-precision type. These defaults apply to instance variables when not explicitly initialized. They ensure consistent behavior in floating-point calculations.",
            "questionRu": "Какое значение по умолчанию у типов float и double в Java?",
            "answerRu": "Значение по умолчанию для типа данных float в Java — 0.0f, а для double — 0.0d. Float — это 32-битный тип с одинарной точностью, а double — 64-битный тип с двойной точностью. Эти значения применяются к переменным экземпляра, если они не инициализированы явно. Они обеспечивают единообразное поведение при вычислениях с плавающей точкой.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 21,
            "questionEn": "What is the Wrapper class in Java?",
            "answerEn": "A wrapper class in Java encapsulates primitive data types into objects. It allows primitives like int or boolean to be used in contexts requiring objects, such as collections. Java provides eight wrapper classes: Boolean, Byte, Short, Integer, Character, Long, Float, and Double. Wrapper classes also enable additional functionality, like converting strings to primitives. Developers can create custom wrapper classes for specific needs.",
            "questionRu": "Что такое класс-обертка в Java?",
            "answerRu": "Класс-обертка в Java преобразует примитивные типы данных в объекты. Это позволяет использовать примитивы, такие как int или boolean, в контекстах, требующих объектов, например, в коллекциях. Java предоставляет восемь классов-оберток: Boolean, Byte, Short, Integer, Character, Long, Float и Double. Классы-обертки также добавляют функциональность, например, конвертацию строк в примитивы. Разработчики могут создавать собственные классы-обертки для специфических задач.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 22,
            "questionEn": "Why do we need wrapper classes?",
            "answerEn": "The wrapper class is an object class that encapsulates the primitive data types, and we need them for the following reasons:\nWrapper classes are final and immutable.\nProvides methods like valueOf(), parseInt(), etc.\nIt provides the feature of autoboxing and unboxing.",
            "questionRu": "Зачем нужны классы-обертки?",
            "answerRu": "Класс-обертка — это объектный класс, который инкапсулирует примитивные типы данных, и он нужен по следующим причинам:\nКлассы-обертки являются финальными и неизменяемыми.\nОни предоставляют методы, такие как valueOf(), parseInt() и др.\nПоддерживается функция автоупаковки и автораспаковки.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 23,
            "questionEn": "Differentiate between instance and local variables.",
            "answerEn": "Instance variables are declared outside methods and have default values, while local variables are declared within methods and lack default values. Instance variables can be used throughout the class, whereas the scope of local variables is limited to the method they are defined in.",
            "questionRu": "Чем отличаются экземплярные и локальные переменные?",
            "answerRu": "Переменные экземпляра объявляются вне методов и имеют значения по умолчанию, в то время как локальные переменные объявляются внутри методов и не имеют значений по умолчанию. Переменные экземпляра доступны на всем протяжении класса, тогда как область видимости локальных переменных ограничена методом, в котором они определены.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 24,
            "questionEn": "What are the default values assigned to variables and instances in Java?",
            "answerEn": "In Java, uninitialized instance variables are assigned default values by the compiler. Numeric types like byte, short, int, long, float, and double default to 0 or 0.0. The boolean type defaults to false, while the char type defaults to the null character '\\u0000'. Object types, such as classes, interfaces, and arrays, default to null. These defaults ensure predictable behavior in Java programs.",
            "questionRu": "Какие значения по умолчанию присваиваются переменным и экземплярам в Java?",
            "answerRu": "В Java неинициализированные переменные экземпляра получают значения по умолчанию от компилятора. Числовые типы, такие как byte, short, int, long, float и double, по умолчанию равны 0 или 0.0. Тип boolean по умолчанию равен false, а тип char — символу '\\u0000'. Объекты, включая классы, интерфейсы и массивы, по умолчанию равны null. Эти значения обеспечивают предсказуемое поведение в программах на Java.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 25,
            "questionEn": "What is a Class Variable?",
            "answerEn": "A class variable in Java, also called a static variable, is declared with the static keyword within a class but outside methods. It is shared across all instances of the class and the class itself, existing as a single copy regardless of object count. This allows tracking shared state, like a counter of created objects. Class variables are initialized once and retain their value throughout the program. They differ from instance variables, which are unique per object.",
            "questionRu": "Что такое классовая переменная?",
            "answerRu": "Классовая переменная в Java, также называемая статической переменной, объявляется с ключевым словом static внутри класса, но вне методов. Она общая для всех экземпляров класса и самого класса, существуя в единственном экземпляре независимо от количества объектов. Это позволяет отслеживать общее состояние, например, счетчик созданных объектов. Классовые переменные инициализируются один раз и сохраняют значение на протяжении программы. Они отличаются от переменных экземпляра, которые уникальны для каждого объекта.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 26,
            "questionEn": "What is the default value stored in Local Variables?",
            "answerEn": "There is no default value stored with local variables. Also, primitive variables and objects don’t have any default values.",
            "questionRu": "Какое значение по умолчанию у локальных переменных?",
            "answerRu": "Локальные переменные не имеют значений по умолчанию. Также примитивные переменные и объекты не обладают значениями по умолчанию.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 27,
            "questionEn": "Explain the difference between instance variable and a class variable.",
            "answerEn": "An instance variable is declared without the static keyword and belongs to a specific object, allowing each instance to hold unique values. A class variable, declared with the static keyword, is shared across all instances and the class itself, maintaining a single value. Instance variables are independent, tied to individual objects, while class variables are common to all objects. For example, an instance variable can store different names for each object, but a class variable might hold a constant like PI. This distinction supports both object-specific and shared data in Java.",
            "questionRu": "Чем отличается экземплярная переменная от классовой?",
            "answerRu": "Переменная экземпляра объявляется без ключевого слова static и принадлежит конкретному объекту, позволяя каждому экземпляру хранить уникальные значения. Классовая переменная, объявленная с ключевым словом static, общая для всех экземпляров и самого класса, сохраняя одно значение. Переменные экземпляра независимы, привязаны к отдельным объектам, тогда как классовые переменные едины для всех объектов. Например, переменная экземпляра может хранить разные имена для каждого объекта, а классовая переменная — константу, такую как PI. Это различие поддерживает как объектно-специфичные, так и общие данные в Java.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 28,
            "questionEn": "What is a static variable?",
            "answerEn": "A static variable in Java is declared with the static keyword and shared across all instances of a class. Only one copy of the variable exists at the class level, regardless of the number of objects created. It is typically used to store data common to all objects, such as a counter or a constant. For example, a static variable can track the total number of objects instantiated. Static variables are initialized when the class is loaded by the JVM.",
            "questionRu": "Что такое статическая переменная?",
            "answerRu": "Статическая переменная в Java объявляется с ключевым словом static и является общей для всех экземпляров класса. Существует только одна копия переменной на уровне класса, независимо от количества созданных объектов. Она обычно используется для хранения данных, общих для всех объектов, например, счетчика или константы. К примеру, статическая переменная может отслеживать общее количество созданных объектов. Статические переменные инициализируются при загрузке класса JVM.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 29,
            "questionEn": "What is the difference between System.out, System.err, and System.in?",
            "answerEn": "System.out is a PrintStream that outputs data, like results, to the console in standard color. System.err, also a PrintStream, displays error messages, often in red to distinguish them in IDEs. System.in is an InputStream that reads user input from the terminal. Unlike System.out and System.err, System.in requires a Scanner to process input effectively. These streams manage interaction between a Java program and the console.",
            "questionRu": "Чем отличаются System.out, System.err и System.in?",
            "answerRu": "System.out — это PrintStream, который выводит данные, например результаты, на консоль в стандартном цвете. System.err, тоже PrintStream, отображает сообщения об ошибках, часто красным цветом в IDE для различия. System.in — это InputStream, который считывает ввод пользователя с терминала. В отличие от System.out и System.err, System.in требует Scanner для эффективной обработки ввода. Эти потоки управляют взаимодействием Java-программы с консолью.",
            "category": "Input/Output Streams (IO/NIO)",
            "level": "Junior"
        },
        {
            "id": 30,
            "questionEn": "What do you understand by an IO stream?",
            "answerEn": "An IO stream in Java is a sequence of data handled by the java.io package for input and output operations. Streams support reading and writing various data types, objects, and files efficiently. For example, FileInputStream reads raw bytes from a file. They enable flexible data transfer between programs and external resources.",
            "questionRu": "Что вы понимаете под потоком ввода-вывода?",
            "answerRu": "Поток ввода-вывода (IO stream) в Java — это последовательность данных, обрабатываемая пакетом java.io для операций ввода и вывода. Потоки поддерживают эффективное чтение и запись различных типов данных, объектов и файлов. Например, FileInputStream считывает необработанные байты из файла. Они обеспечивают гибкий обмен данными между программами и внешними ресурсами.",
            "category": "Input/Output Streams (IO/NIO)",
            "level": "Junior"
        },
        {
            "id": 31,
            "questionEn": "What is the difference between Reader/Writer and InputStream/OutputStream?",
            "answerEn": "InputStream/OutputStream classes handle raw byte data, such as binary files or images. Reader/Writer classes process character data, making them suitable for text and Unicode handling. InputStream/OutputStream methods accept byte arrays, while Reader/Writer methods work with character arrays. Reader/Writer classes are more efficient for text and support internationalization. Use InputStream/OutputStream for binary data and Reader/Writer for text-based operations.",
            "questionRu": "Чем отличаются Reader/Writer от InputStream/OutputStream?",
            "answerRu": "Классы InputStream/OutputStream обрабатывают необработанные байтовые данные, такие как бинарные файлы или изображения. Классы Reader/Writer работают с символьными данными, подходя для текста и обработки Unicode. Методы InputStream/OutputStream принимают массивы байтов, тогда как методы Reader/Writer используют массивы символов. Reader/Writer более эффективны для текста и поддерживают интернационализацию. Используйте InputStream/OutputStream для бинарных данных, а Reader/Writer для текстовых операций.",
            "category": "Input/Output Streams (IO/NIO)",
            "level": "Junior"
        },
        {
            "id": 32,
            "questionEn": "What are the super most classes for all the streams?",
            "answerEn": "Stream classes in Java are categorized into ByteStream (InputStream and OutputStream) and CharacterStream (Reader and Writer) hierarchies. The super-most class for all InputStream classes is java.io.InputStream, and for OutputStream classes, it is java.io.OutputStream. Similarly, the super-most class for Reader classes is java.io.Reader, and for Writer classes, it is java.io.Writer. These superclasses provide common methods for their respective stream types. They form the foundation for handling byte and character data in Java I/O.",
            "questionRu": "Какие суперклассы для всех потоков?",
            "answerRu": "Классы потоков в Java делятся на ByteStream (InputStream и OutputStream) и CharacterStream (Reader и Writer) иерархии. Суперклассом для всех классов InputStream является java.io.InputStream, а для OutputStream — java.io.OutputStream. Аналогично, суперклассом для Reader является java.io.Reader, а для Writer — java.io.Writer. Эти суперклассы предоставляют общие методы для своих типов потоков. Они составляют основу для обработки байтовых и символьных данных в Java I/O.",
            "category": "Input/Output Streams (IO/NIO)",
            "level": "Junior"
        },
        {
            "id": 33,
            "questionEn": "What are FileInputStream and FileOutputStream?",
            "answerEn": "FileInputStream in Java reads data from a file as a stream of bytes, primarily for binary data like images or audio. FileOutputStream writes data byte by byte into a file, typically used for raw binary content such as pictures. Both classes belong to the java.io package and extend the InputStream and OutputStream hierarchies. FileInputStream is ideal for input operations, while FileOutputStream handles output to files. They enable efficient handling of binary file operations in Java.",
            "questionRu": "Что такое FileInputStream и FileOutputStream?",
            "answerRu": "FileInputStream в Java считывает данные из файла в виде потока байтов, преимущественно для бинарных данных, таких как изображения или аудио. FileOutputStream записывает данные побайтово в файл, обычно для необработанного бинарного контента, например, картинок. Оба класса относятся к пакету java.io и расширяют иерархии InputStream и OutputStream. FileInputStream подходит для операций ввода, а FileOutputStream — для вывода в файлы. Они обеспечивают эффективную обработку бинарных файлов в Java.",
            "category": "Input/Output Streams (IO/NIO)",
            "level": "Junior"
        },
        {
            "id": 34,
            "questionEn": "What is the purpose of using BufferedInputStream and BufferedOutputStream?",
            "answerEn": "BufferedInputStream and BufferedOutputStream classes enhance I/O performance by using buffering. They store data in a buffer, reducing direct interactions with the underlying system, such as disk or network. This minimizes overhead by reading or writing data in larger chunks instead of small pieces. BufferedInputStream reads data efficiently from a stream, while BufferedOutputStream writes data effectively to a file. These classes optimize resource usage in Java I/O operations.",
            "questionRu": "Какова цель использования BufferedInputStream и BufferedOutputStream?",
            "answerRu": "Классы BufferedInputStream и BufferedOutputStream повышают производительность ввода-вывода за счет буферизации. Они сохраняют данные в буфере, уменьшая прямые обращения к системе, например, к диску или сети. Это снижает накладные расходы, позволяя читать или записывать данные большими блоками вместо мелких частей. BufferedInputStream эффективно считывает данные из потока, а BufferedOutputStream — записывает в файл. Эти классы оптимизируют использование ресурсов в операциях ввода-вывода Java",
            "category": "Input/Output Streams (IO/NIO)",
            "level": "Junior"
        },
        {
            "id": 35,
            "questionEn": "What are FilterStreams?",
            "answerEn": "FilterStreams in Java are streams that process or transform data from underlying streams based on a predicate. They do not filter data immediately but create a new stream containing elements that match the condition when traversed. Commonly used FilterStreams include BufferedInputStream and BufferedOutputStream, which enhance performance. They are part of the java.io package and support efficient I/O operations. This approach allows flexible data manipulation in Java streams.",
            "questionRu": "Что такое FilterStreams?",
            "answerRu": "FilterStreams в Java — это потоки, которые обрабатывают или преобразуют данные из базовых потоков на основе предиката. Они не фильтруют данные сразу, а создают новый поток, содержащий элементы, соответствующие условию, при его обработке. К типичным FilterStreams относятся BufferedInputStream и BufferedOutputStream, улучшающие производительность. Они входят в пакет java.io и поддерживают эффективные операции ввода-вывода. Такой подход обеспечивает гибкую манипуляцию данными в потоках Java.",
            "category": "Input/Output Streams (IO/NIO)",
            "level": "Junior"
        },
        {
            "id": 36,
            "questionEn": "What is an I/O filter?",
            "answerEn": "An I/O filter, or Input/Output filter, is an object that processes data by reading from one stream and writing to another. It acts as an intermediary between input and output sources, transforming or managing the data flow. In Java, I/O filters are implemented using the java.io package, which provides classes like FilterInputStream and FilterOutputStream. They are commonly used for tasks such as data compression, encryption, or buffering.",
            "questionRu": "Что такое фильтр ввода-вывода?",
            "answerRu": "I/O-фильтр, или фильтр ввода-вывода, — это объект, который обрабатывает данные, считывая их из одного потока и записывая в другой. Он служит посредником между источниками ввода и вывода, преобразуя или управляя потоком данных. В Java I/O-фильтры реализуются с помощью пакета java.io, который включает классы, такие как FilterInputStream и FilterOutputStream. Их часто используют для задач, таких как сжатие данных, шифрование или буферизация.",
            "category": "Input/Output Streams (IO/NIO)",
            "level": "Junior"
        },
        {
            "id": 37,
            "questionEn": "How many ways can you take input from the console?",
            "answerEn": "In Java, there are four main ways to take input from the console. First, command-line arguments allow passing data via the args array in the main method. Second, the BufferedReader class from java.io reads text from an input stream, typically using readLine(). Third, the Console class provides direct access to console input with methods like readLine(). Finally, the Scanner class from java.util is a versatile tool for parsing and reading various data types from the console.",
            "questionRu": "Сколько способов взять ввод из консоли?",
            "answerRu": "В Java существует четыре основных способа ввода данных с консоли. Первый — аргументы командной строки, которые передаются через массив args в методе main. Второй — класс BufferedReader из пакета java.io, который считывает текст из входного потока, обычно с помощью readLine(). Третий — класс Console, предоставляющий прямой доступ к вводу с консоли через методы вроде readLine(). Наконец, класс Scanner из java.util — универсальный инструмент для разбора и чтения различных типов данных с консоли.",
            "category": "Input/Output Streams (IO/NIO)",
            "level": "Junior"
        },
        {
            "id": 38,
            "questionEn": "Difference in the use of print, println, and printf.",
            "answerEn": "In Java, print, println, and printf are methods used to output data, but they differ in behavior. print displays the text and keeps the cursor on the same line. println prints the text and moves the cursor to the next line. printf allows formatted output using format specifiers, such as %d for integers or %s for strings. Each serves a specific purpose depending on the desired output layout and formatting needs.",
            "questionRu": "Чем отличаются print, println и printf?",
            "answerRu": "В Java методы print, println и printf используются для вывода данных, но их поведение различается. print отображает текст, оставляя курсор на той же строке. println выводит текст и переводит курсор на следующую строку. printf позволяет форматировать вывод с помощью спецификаторов, таких как %d для целых чисел или %s для строк. Каждый метод подходит для определённых задач в зависимости от нужного формата и структуры вывода.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 39,
            "questionEn": "What are operators?",
            "answerEn": "Operators in Java are special symbols that perform operations on variables and values. They include arithmetic operators like '+' for addition, relational operators like '==' for equality, and logical operators like '&&' for conjunction. These operators enable tasks such as calculations, comparisons, and logical evaluations in programs. They are fundamental to manipulating data and controlling program flow.",
            "questionRu": "Что такое операторы?",
            "answerRu": "Операторы в Java — это специальные символы, выполняющие операции над переменными и значениями. К ним относятся арифметические операторы, такие как '+' для сложения, реляционные операторы, такие как '==' для равенства, и логические операторы, такие как '&&' для конъюнкции. Эти операторы позволяют выполнять вычисления, сравнения и логические оценки в программах. Они являются основой для манипуляции данными и управления потоком программы.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 40,
            "questionEn": "How many types of operators are available in Java?",
            "answerEn": "Java has 9 types of operators for manipulating variables and values. These include Arithmetic, Unary, Assignment, Relational, Logical, Ternary, Bitwise, Shift, and instanceof operators. Arithmetic operators perform calculations, while Relational and Logical operators handle comparisons and conditions. Bitwise and Shift operators manage bit-level operations, and instanceof checks object types. These operators collectively enable diverse operations in Java programming.",
            "questionRu": "Сколько типов операторов есть в Java?",
            "answerRu": "В Java существует 9 типов операторов для манипуляции переменными и значениями. К ним относятся арифметические, унарные, присваивания, реляционные, логические, тернарные, побитовые, сдвиговые и оператор instanceof. Арифметические операторы выполняют вычисления, реляционные и логические обрабатывают сравнения и условия. Побитовые и сдвиговые операторы работают с битовыми операциями, а instanceof проверяет типы объектов. Эти операторы вместе обеспечивают разнообразные операции в программировании на Java.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 41,
            "questionEn": "Explain the difference between >> and >>> operators.",
            "answerEn": "The >> operator in Java performs a signed right shift, preserving the sign bit of the number. It shifts bits to the right and fills the leftmost bits with the sign bit, which is 1 for negative numbers. In contrast, the >>> operator performs an unsigned right shift, filling the leftmost bits with zeros regardless of the sign. For example, -16 >> 1 results in -8, while -16 >>> 1 yields a large positive number. This difference makes >> suitable for signed operations and >>> for unsigned bit manipulations.",
            "questionRu": "Объясните разницу между операторами >> и >>>.",
            "answerRu": "Оператор >> в Java выполняет знаковый сдвиг вправо, сохраняя знаковый бит числа. Он сдвигает биты вправо и заполняет старшие биты знаковым битом, который равен 1 для отрицательных чисел. В отличие от него, оператор >>> выполняет беззнаковый сдвиг вправо, заполняя старшие биты нулями независимо от знака. Например, -16 >> 1 дает -8, а -16 >>> 1 — большое положительное число. Это различие делает >> подходящим для знаковых операций, а >>> — для беззнаковых манипуляций с битами.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 42,
            "questionEn": "Which Java operator is right associative?",
            "answerEn": "There is only one operator which is right associative which is = operator.",
            "questionRu": "Какой оператор в Java является правоассоциативным?",
            "answerRu": "Существует только один оператор с правой ассоциативностью, это оператор =.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 43,
            "questionEn": "What is dot operator?",
            "answerEn": "The dot operator (.) in Java accesses instance variables and methods of class objects. It also navigates classes and sub-packages within a package hierarchy. For example, System.out.println() uses the dot operator to call the println method. This operator enables structured access to object members and package components. It is fundamental for object-oriented programming in Java.",
            "questionRu": "Что такое оператор точки?",
            "answerRu": "Оператор точки (.) в Java используется для доступа к переменным экземпляра и методам объектов класса. Он также позволяет обращаться к классам и подпакетам в иерархии пакета. Например, System.out.println() применяет оператор точки для вызова метода println. Этот оператор обеспечивает структурированный доступ к членам объектов и компонентам пакета. Он является основой объектно-ориентированного программирования в Java",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 44,
            "questionEn": "What is covariant return type?",
            "answerEn": "A covariant return type in Java allows an overriding method in a subclass to return a subtype of the parent method's return type. This means the return type can be more specific in the child class while remaining compatible with the parent. It eliminates unnecessary type casting, improving code readability and maintainability. It also helps avoid runtime ClassCastExceptions during method calls. Covariant return types enhance flexibility in object-oriented design.",
            "questionRu": "Что такое ковариантный возвращаемый тип?",
            "answerRu": "Ковариантный тип возврата в Java позволяет переопределяющему методу в подклассе возвращать подтип типа возврата родительского метода. Это означает, что тип возврата в дочернем классе может быть более конкретным, оставаясь совместимым с родительским. Это устраняет лишние приведения типов, улучшая читаемость и поддерживаемость кода. Также это помогает избежать исключений ClassCastException во время выполнения. Ковариантные типы возврата повышают гибкость в объектно-ориентированном проектировании.",
            "category": "Object-Oriented Programming (OOP)",
            "level": "Junior"
        },
        {
            "id": 45,
            "questionEn": "What is the transient keyword?",
            "answerEn": "The transient keyword in Java marks a variable to be excluded from serialization. During serialization, JVM ignores the variable's original value and saves its default value instead. This is useful for sensitive data, like passwords, that should not be persisted. For example, marking a password field as transient prevents it from being saved to a file. It enhances security and control over serialized data.",
            "questionRu": "Что такое ключевое слово transient?",
            "answerRu": "Ключевое слово transient в Java помечает переменную, которую нужно исключить из сериализации. Во время сериализации JVM игнорирует исходное значение переменной и сохраняет значение по умолчанию. Это полезно для конфиденциальных данных, таких как пароли, которые не должны сохраняться. Например, пометка поля пароля как transient предотвращает его сохранение в файл. Оно улучшает безопасность и контроль над сериализованными данными.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 46,
            "questionEn": "What’s the difference between the methods sleep() and wait()?",
            "answerEn": "The sleep() method, part of the Thread class, pauses the current thread for a specified time without releasing any locks. In contrast, the wait() method, from the Object class, suspends a thread and releases its lock, allowing other threads to proceed. Sleep() is static and does not throw InterruptedException, while wait() is non-static and can throw it if interrupted. Sleep() is used to delay execution, whereas wait() pauses a thread until notified by another thread. These differences make sleep() suitable for delays and wait() for thread synchronization.",
            "questionRu": "Чем отличаются методы sleep() и wait()?",
            "answerRu": "Метод sleep(), принадлежащий классу Thread, приостанавливает текущий поток на заданное время, не освобождая удерживаемые замки. Напротив, метод wait(), из класса Object, приостанавливает поток и освобождает его замок, позволяя другим потокам продолжить работу. Sleep() — статический и не выбрасывает InterruptedException, тогда как wait() — нестатический и может выбросить это исключение при прерывании. Sleep() используется для задержки выполнения, а wait() — для приостановки потока до уведомления другим потоком. Эти различия делают sleep() подходящим для задержек, а wait() — для синхронизации потоков.",
            "category": "Multithreading & Concurrency",
            "level": "Junior"
        },
        {
            "id": 47,
            "questionEn": "What are the differences between String and StringBuffer?",
            "answerEn": "A String stores a sequence of characters and is immutable, while StringBuffer provides functionality to modify strings and is mutable. String lacks thread safety, whereas StringBuffer is thread-safe, allowing multiple threads to call its methods simultaneously.",
            "questionRu": "Чем отличаются String и StringBuffer?",
            "answerRu": "String хранит последовательность символов и является неизменяемым, тогда как StringBuffer предоставляет возможности для модификации строк и является изменяемым. String не поддерживает многопоточность, в то время как StringBuffer является потокобезопасным, позволяя нескольким потокам одновременно вызывать его методы.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 48,
            "questionEn": "What are the differences between StringBuffer and StringBuilder?",
            "answerEn": "StringBuffer is a thread-safe class for mutable strings, ensuring that multiple threads cannot call its methods simultaneously. StringBuilder, also for mutable strings, is not thread-safe, allowing concurrent method calls by multiple threads. Due to synchronization, StringBuffer is slower, while StringBuilder offers faster performance in single-threaded applications.",
            "questionRu": "Чем отличаются StringBuffer и StringBuilder?",
            "answerRu": "StringBuffer — это потокобезопасный класс для изменяемых строк, гарантирующий, что несколько потоков не могут одновременно вызывать его методы. StringBuilder, также предназначенный для изменяемых строк, не является потокобезопасным, позволяя нескольким потокам вызывать методы одновременно. Из-за синхронизации StringBuffer работает медленнее, тогда как StringBuilder быстрее в однопоточных приложениях.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 49,
            "questionEn": "Which among StringBuilder or StringBuffer should be preferred when there are a lot of updates required to be done in the data?",
            "answerEn": "Strings are immutable, making them inefficient for frequent updates, whereas StringBuilder and StringBuffer are suitable due to their mutability. Use StringBuffer for thread-safe operations in multi-threaded contexts, ensuring synchronized access. Prefer StringBuilder for better performance in single-threaded applications with frequent updates.",
            "questionRu": "Какой из StringBuilder или StringBuffer предпочесть, если требуется много обновлений данных?",
            "answerRu": "Строки неизменяемы, что делает их неэффективными для частых обновлений, тогда как StringBuilder и StringBuffer подходят благодаря своей изменяемости. Используйте StringBuffer для потокобезопасных операций в многопоточных контекстах, обеспечивая синхронизированный доступ. Предпочтите StringBuilder для лучшей производительности в однопоточных приложениях с частыми обновлениями.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 50,
            "questionEn": "Why is StringBuffer called mutable?",
            "answerEn": "StringBuffer is called mutable because it allows modification of its character sequence without creating new objects. Unlike the immutable String class, StringBuffer supports operations like append and insert to alter its content. This mutability avoids the overhead of generating multiple String objects during frequent updates. It provides an efficient alternative for dynamic string manipulation in Java. The class is designed for scenarios requiring extensive string modifications.",
            "questionRu": "Почему StringBuffer называют изменяемым?",
            "answerRu": "StringBuffer называют изменяемым, так как он позволяет изменять последовательность символов без создания новых объектов. В отличие от неизменяемого класса String, StringBuffer поддерживает операции, такие как append и insert, для изменения содержимого. Эта изменяемость устраняет накладные расходы на создание множества объектов String при частых обновлениях. Он обеспечивает эффективную альтернативу для динамической манипуляции строками в Java. Класс предназначен для сценариев, требующих обширных изменений строк.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 51,
            "questionEn": "How is the creation of a String using new() different from that of a literal?",
            "answerEn": "A String literal is stored in the String pool in heap memory and reused if the same literal exists, while new() creates a new String object in heap memory regardless of existing content. Literals are referenced from the stack, whereas new() allocates dynamic memory outside the pool. For example, \"ABC\" as a literal reuses the same object, but new String(\"ABC\") always creates a distinct object. This makes literals more memory-efficient but less flexible than new(). The choice impacts memory usage and performance in Java applications.",
            "questionRu": "Чем отличается создание String через new() от литерала?",
            "answerRu": "Строковый литерал хранится в пуле строк в куче и переиспользуется при совпадении, тогда как new() создает новый объект String в куче независимо от существующего содержимого. Литералы ссылаются из стека, а new() выделяет динамическую память вне пула. Например, литерал \"ABC\" переиспользует объект, но new String(\"ABC\") всегда создает новый. Это делает литералы более эффективными по памяти, но менее гибкими, чем new(). Выбор влияет на использование памяти и производительность в приложениях Java.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 52,
            "questionEn": "What is an array in Java?",
            "answerEn": "An array in Java is a data structure that stores a fixed-size sequence of elements of the same type. Elements are accessed via their index, ranging from 0 to the array's length minus 1. Arrays are declared using square brackets, with their size specified at creation. This structure is efficient for storing and retrieving data in a contiguous memory block.",
            "questionRu": "Что такое массив в Java?",
            "answerRu": "Массив в Java — это структура данных, которая хранит последовательность фиксированного размера из элементов одного типа. Элементы доступны по индексу, который начинается с 0 и до длины массива минус 1. Массивы объявляются с помощью квадратных скобок, а их размер указывается при создании. Эта структура эффективна для хранения и извлечения данных в непрерывном блоке памяти.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 53,
            "questionEn": "On which memory arrays are created in Java?",
            "answerEn": "Arrays in Java are created in heap memory, allocated dynamically when using the new keyword. The heap is managed by the Java Virtual Machine (JVM) and shared across all threads. Memory for arrays is reclaimed by the JVM’s garbage collector when no longer in use. This dynamic allocation allows array sizes to be determined at runtime. Arrays reside in heap to support efficient memory management in Java.",
            "questionRu": "В какой памяти создаются массивы в Java?",
            "answerRu": "Массивы в Java создаются в куче, выделяемой динамически при использовании ключевого слова new. Куча управляется виртуальной машиной Java (JVM) и является общей для всех потоков. Память для массивов освобождается сборщиком мусора JVM, когда она больше не используется. Динамическое выделение позволяет определять размер массива во время выполнения. Массивы размещаются в куче для эффективного управления памятью в Java.",
            "category": "JVM Memory Management & Garbage Collection",
            "level": "Junior"
        },
        {
            "id": 54,
            "questionEn": "What are the types of an array?",
            "answerEn": "Arrays in Java are classified into two types: single-dimensional and multi-dimensional. Single-dimensional arrays have one dimension, storing elements like integers or strings in a linear sequence. Multi-dimensional arrays have two or more dimensions, such as a 2D array representing a matrix. Single-dimensional arrays are simpler, while multi-dimensional arrays handle complex data structures. Both types are stored in heap memory and support various data types.",
            "questionRu": "Какие типы массивов существуют?",
            "answerRu": "Массивы в Java делятся на два типа: одномерные и многомерные. Одномерные массивы имеют одну размерность, храня элементы, такие как целые числа или строки, в линейной последовательности. Многомерные массивы имеют две или более размерности, например, 2D-массив, представляющий матрицу. Одномерные массивы проще, а многомерные подходят для сложных структур данных. Оба типа хранятся в куче и поддерживают различные типы данных.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 55,
            "questionEn": "Why does the Java array index start with 0?",
            "answerEn": "Java array indices start with 0 because the index represents the offset from the array's base address in memory. The first element, being at the starting position, has an offset of 0. This convention aligns with how memory addresses are calculated using the base address plus the index. It also follows the design of languages like C, influencing Java’s array indexing. Using 0-based indexing simplifies memory management and arithmetic in programming.",
            "questionRu": "Почему индекс массива в Java начинается с 0?",
            "answerRu": "Индексы массивов в Java начинаются с 0, поскольку индекс указывает смещение от базового адреса массива в памяти. Первый элемент, находящийся в начальной позиции, имеет смещение 0. Эта традиция соответствует расчету адресов памяти через базовый адрес плюс индекс. Она также унаследована от языков, таких как C, повлиявших на дизайн Java. Нулевая индексация упрощает управление памятью и арифметику в программировании.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 56,
            "questionEn": "What is the difference between int array[] and int[] array?",
            "answerEn": "Both int array[] and int[] array declare an array of integers in Java, with no functional difference between them. The int arr[] syntax follows the C-style, while int[] arr adheres to Java-style conventions. It is recommended to use the Java-style syntax for better readability and consistency with other language constructs.",
            "questionRu": "Чем отличается int array[] от int[] array?",
            "answerRu": "Оба варианта int array[] и int[] array объявляют массив целых чисел в Java, и между ними нет функциональных различий. Синтаксис int arr[] соответствует стилю C, тогда как int[] arr следует конвенциям Java. Рекомендуется использовать синтаксис Java-стиля для лучшей читаемости и согласованности с другими конструкциями языка.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 57,
            "questionEn": "How to copy an array in Java?",
            "answerEn": "Java provides multiple methods to copy an array based on specific needs. The clone() method creates a shallow copy, sharing memory with the original array. System.arraycopy() performs a deep copy, creating a new array with the same values. Arrays.copyOf() copies the array to a new one with a specified length, while Arrays.copyOfRange() copies a specific range of elements. These methods offer flexibility for array copying in Java.",
            "questionRu": "Как скопировать массив в Java?",
            "answerRu": "В Java существует несколько способов копирования массива в зависимости от потребностей. Метод clone() создает поверхностную копию, разделяя память с исходным массивом. System.arraycopy() выполняет глубокое копирование, создавая новый массив с теми же значениями. Arrays.copyOf() копирует массив в новый с указанной длиной, а Arrays.copyOfRange() копирует заданный диапазон элементов. Эти методы обеспечивают гибкость для копирования массивов в Java.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 58,
            "questionEn": "What do you understand by the jagged array?",
            "answerEn": "A jagged array in Java is a two-dimensional array where each row can have a different length. Unlike a regular 2D array with fixed row sizes, a jagged array provides flexibility by allowing variable-length rows. This is useful for handling data of varying sizes or optimizing memory usage. For example, you can declare it as int[][] arr = { {1, 2}, {3, 4, 5}, {6} };, where each sub-array has a unique length.",
            "questionRu": "Что вы понимаете под неровным массивом?",
            "answerRu": "Зубчатый массив в Java — это двумерный массив, в котором каждая строка может иметь разную длину. В отличие от обычного двумерного массива с фиксированным размером строк, зубчатый массив обеспечивает гибкость благодаря переменной длине строк. Это полезно для работы с данными разного размера или оптимизации использования памяти. Например, его можно объявить как int[][] arr = { {1, 2}, {3, 4, 5}, {6} };, где каждая подстрока имеет уникальную длину.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 59,
            "questionEn": "Is it possible to make an array volatile?",
            "answerEn": "In Java, you cannot directly make an entire array volatile. The volatile keyword can only be applied to individual variables, not to arrays or collections. When a variable is marked as volatile, its value is always read from and written to the main memory, bypassing thread-local caches. This ensures that changes to the variable are visible to all threads, but for an array, only the reference can be volatile, not its elements.",
            "questionRu": "Можно ли сделать массив volatile?",
            "answerRu": "В Java нельзя напрямую сделать весь массив volatile. Ключевое слово volatile применимо только к отдельным переменным, но не к массивам или коллекциям. Когда переменная помечена как volatile, её значение всегда читается из основной памяти и записывается в неё, минуя локальные кэши потоков. Это гарантирует, что изменения переменной видны всем потокам, но для массива volatile может быть только ссылка, а не его элементы.",
            "category": "Multithreading & Concurrency",
            "level": "Junior"
        },
        {
            "id": 60,
            "questionEn": "What are the advantages and disadvantages of an array?",
            "answerEn": "Arrays in Java offer fast, direct access to elements with O(1) time complexity due to contiguous memory allocation. They are memory-efficient for fixed-size data and simple to implement, making them beginner-friendly. However, their fixed size limits flexibility, requiring a new array and data copying to resize, which is costly. Additionally, arrays only store homogeneous data types and can waste memory if not fully utilized.",
            "questionRu": "Каковы преимущества и недостатки массива?",
            "answerRu": "Массивы в Java обеспечивают быстрый прямой доступ к элементам с временной сложностью O(1) благодаря непрерывному выделению памяти. Они эффективны по памяти для данных фиксированного размера и просты в реализации, что удобно для новичков. Однако их фиксированный размер ограничивает гибкость, требуя создания нового массива и копирования данных для изменения размера, что затратно. Кроме того, массивы поддерживают только однородные типы данных и могут тратить память впустую, если не полностью заполнены.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 61,
            "questionEn": "What is an object-oriented paradigm?",
            "answerEn": "The object-oriented paradigm is a programming approach where objects serve as the fundamental entities. It organizes code around data and behavior, using concepts like encapsulation, inheritance, and polymorphism. This paradigm solves problems by modeling real-world entities as objects that interact through methods. It differs from other paradigms like imperative or functional programming by focusing on object interactions.",
            "questionRu": "Что такое объектно-ориентированная парадигма?",
            "answerRu": "Объектно-ориентированная парадигма — это подход к программированию, где объектами являются базовые сущности. Она организует код вокруг данных и поведения, используя такие концепции, как инкапсуляция, наследование и полиморфизм. Эта парадигма решает задачи, моделируя реальные сущности как объекты, взаимодействующие через методы. Она отличается от других парадигм, таких как императивная или функциональная, акцентом на взаимодействие объектов.",
            "category": "Object-Oriented Programming (OOP)",
            "level": "Junior"
        },
        {
            "id": 62,
            "questionEn": "What are the main concepts of OOPs in Java?",
            "answerEn": "The main concepts of OOP in Java are inheritance, polymorphism, abstraction, and encapsulation. Inheritance allows a class to inherit properties and methods from another class, promoting code reuse. Polymorphism enables one interface or method to be used for multiple actions, enhancing flexibility. Abstraction hides complex implementation details, exposing only essential features, while encapsulation bundles data and methods, restricting direct access to ensure security.",
            "questionRu": "Какие основные концепции ООП в Java?",
            "answerRu": "Основные концепции ООП в Java — это наследование, полиморфизм, абстракция и инкапсуляция. Наследование позволяет классу унаследовать свойства и методы другого класса, способствуя повторному использованию кода. Полиморфизм дает возможность использовать один интерфейс или метод для разных действий, повышая гибкость. Абстракция скрывает сложные детали реализации, показывая только ключевые функции, а инкапсуляция объединяет данные и методы, ограничивая прямой доступ для обеспечения безопасности.",
            "category": "Object-Oriented Programming (OOP)",
            "level": "Junior"
        },
        {
            "id": 63,
            "questionEn": "What is the difference between an object-oriented and object-based programming language?",
            "answerEn": "An object-oriented programming (OOP) language supports inheritance, polymorphism, abstraction, and encapsulation for complex designs. An object-based programming language focuses only on objects and encapsulation, omitting broader OOP features. OOP languages like Java and C# offer full functionality. Object-based languages like JavaScript and Visual Basic are more restricted.",
            "questionRu": "Чем отличается объектно-ориентированный язык от объектно-базированного?",
            "answerRu": "Объектно-ориентированный язык (ООП) поддерживает наследование, полиморфизм, абстракцию и инкапсуляцию для сложных систем. Объектно-базированный язык ограничивается объектами и инкапсуляцией, без широких возможностей ООП. Языки ООП, такие как Java и C#, обеспечивают полную функциональность. Объектно-базированные языки, например JavaScript и Visual Basic, более ограничены.",
            "category": "Object-Oriented Programming (OOP)",
            "level": "Junior"
        },
        {
            "id": 64,
            "questionEn": "How is the ‘new’ operator different from the ‘newInstance()’ operator in Java?",
            "answerEn": "The new operator in Java creates an object of a specific class at compile time. In contrast, the newInstance() method, part of the Class or Constructor class, instantiates an object at runtime, allowing dynamic type determination. The new operator is simpler and faster but less flexible. The newInstance() method requires reflection and can throw exceptions like InstantiationException.",
            "questionRu": "Чем отличается оператор ‘new’ от ‘newInstance()’ в Java?",
            "answerRu": "Оператор new в Java создает объект конкретного класса на этапе компиляции. Метод newInstance(), часть класса Class или Constructor, создает объект во время выполнения, позволяя динамически определять тип. Оператор new проще и быстрее, но менее гибок. Метод newInstance() использует рефлексию и может выбрасывать исключения, например InstantiationException.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 65,
            "questionEn": "What are Classes in Java?",
            "answerEn": "In Java, a class is a blueprint that defines the structure and behavior of objects. It groups objects with shared properties and methods, serving as a template for object creation. Classes themselves are not real-world entities, but the objects they produce represent tangible instances. For example, class Car { int speed; void drive() {} } defines a class.",
            "questionRu": "Что такое классы в Java?",
            "answerRu": "В Java класс — это шаблон, определяющий структуру и поведение объектов. Он объединяет объекты с общими свойствами и методами, выступая основой для их создания. Классы сами по себе не являются реальными сущностями, но объекты, созданные на их основе, представляют конкретные экземпляры. Например, class Car { int speed; void drive() {} } определяет класс.",
            "category": "Object-Oriented Programming (OOP)",
            "level": "Junior"
        },
        {
            "id": 66,
            "questionEn": "What is the difference between static (class) method and instance method?",
            "answerEn": "A static method belongs to the class, is called using the class name without creating an object, and can only access static members. An instance method belongs to an object, is called using an object reference, and can access both static and non-static members. Static methods do not use this and cannot be overridden, as they are resolved at compile-time. Instance methods use this and can be overridden, being resolved at runtime.",
            "questionRu": "Чем отличается статический (классовый) метод от метода экземпляра?",
            "answerRu": "Статический метод принадлежит классу, вызывается через имя класса без создания объекта и обращается только к статическим членам. Экземплярный метод принадлежит объекту, вызывается через ссылку на объект и может обращаться к статическим и нестатическим членам. Статические методы не используют this и не переопределяются, так как разрешаются на этапе компиляции. Экземплярные методы используют this и могут переопределяться, разрешаясь во время выполнения.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 67,
            "questionEn": "What is this keyword in Java?",
            "answerEn": "The this keyword in Java refers to the current object in an instance method or constructor. It is used to distinguish instance variables from local variables with the same name. For example, in this.name = name;, this accesses the object's field. It can also invoke another constructor in the same class using this().",
            "questionRu": "Что такое ключевое слово ‘this’ в Java?",
            "answerRu": "Ключевое слово this в Java указывает на текущий объект в методе экземпляра или конструкторе. Оно используется для различия полей объекта от локальных переменных с одинаковыми именами. Например, в this.name = name; this обращается к полю объекта. Также оно может вызывать другой конструктор в том же классе через this().",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 68,
            "questionEn": "What are Brief Access Specifiers and Types of Access Specifiers?",
            "answerEn": "Access specifiers in Java control the visibility and accessibility of class members. The four types are public, private, protected, and default (package-private). Public allows access from everywhere, while private restricts access to the same class. Protected permits access within the same package and subclasses, and default limits access to the same package if no specifier is provided.",
            "questionRu": "Что такое спецификаторы доступа и их типы?",
            "answerRu": "Спецификаторы доступа в Java управляют видимостью и доступностью членов класса. Существует четыре типа: public, private, protected и default (пакетный уровень). Public разрешает доступ отовсюду, а private ограничивает доступ только внутри класса. Protected позволяет доступ в пределах пакета и подклассов, а default ограничивает доступ пакетом, если спецификатор не указан.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 69,
            "questionEn": "What will be the initial value of an object reference which is defined as an instance variable?",
            "answerEn": "The initial value of an object reference defined as an instance variable in Java is null. This applies to all reference types, such as objects, when they are not explicitly initialized. It indicates that the variable does not point to any object in memory yet.",
            "questionRu": "Какое начальное значение у ссылки на объект, определенной как переменная экземпляра?",
            "answerRu": "Начальное значение ссылки на объект, определенной как переменная экземпляра в Java, — null. Это относится ко всем ссылочным типам, таким как объекты, если они не инициализированы явно. Оно указывает, что переменная пока не ссылается на объект в памяти.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 70,
            "questionEn": "What is an object?",
            "answerEn": "An object in Java is an instance of a class, representing a real-world entity. It combines data (properties) and behavior (methods) defined by its class. Objects are created using the new keyword, allocating memory for the instance. For example, Car myCar = new Car(); creates an object of the Car class.",
            "questionRu": "Что такое объект?",
            "answerRu": "Объект в Java — это экземпляр класса, представляющий реальную сущность. Он объединяет данные (свойства) и поведение (методы), определенные классом. Объекты создаются с помощью ключевого слова new, выделяя память для экземпляра. Например, Car myCar = new Car(); создает объект класса Car.",
            "category": "Object-Oriented Programming (OOP)",
            "level": "Junior"
        },
        {
            "id": 71,
            "questionEn": "What are the different ways to create objects in Java?",
            "answerEn": "In Java, objects can be created using the new keyword, which instantiates a class directly (e.g., Car car = new Car();). The newInstance() method of the Class or Constructor class creates objects dynamically via reflection. The clone() method duplicates an existing object, while deserialization reconstructs objects from a serialized state. Each method suits different use cases, like runtime flexibility or copying.",
            "questionRu": "Какие есть способы создания объектов в Java?",
            "answerRu": "В Java объекты можно создать с помощью ключевого слова new, которое напрямую создает экземпляр класса (например, Car car = new Car();). Метод newInstance() классов Class или Constructor создает объекты динамически через рефлексию. Метод clone() копирует существующий объект, а десериализация воссоздает объекты из сериализованного состояния. Каждый способ подходит для разных случаев, таких как гибкость во время выполнения или копирование.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 72,
            "questionEn": "What are the advantages and disadvantages of object cloning?",
            "answerEn": "Object cloning in Java, via the clone() method, simplifies replication of complex objects, reducing code size compared to manual initialization. It offers control, as only the class itself can clone its objects due to the protected nature of Object.clone(). However, it requires implementing the Cloneable interface and overriding clone(), adding complexity. By default, it performs a shallow copy, which may lead to issues with nested objects.",
            "questionRu": "Каковы преимущества и недостатки клонирования объектов?",
            "answerRu": "Клонирование объектов в Java через метод clone() упрощает копирование сложных объектов, уменьшая объем кода по сравнению с ручной инициализацией. Оно обеспечивает контроль, так как только сам класс может клонировать свои объекты из-за защищенного характера Object.clone(). Однако требуется реализация интерфейса Cloneable и переопределение clone(), что усложняет процесс. По умолчанию выполняется поверхностное копирование, что может вызвать проблемы с вложенными объектами.",
            "category": "Object-Oriented Programming (OOP)",
            "level": "Junior"
        },
        {
            "id": 73,
            "questionEn": "What are the advantages of passing this into a method instead of the current class object itself?",
            "answerEn": "Passing this into a method ensures a reference to the current object as a final variable, preventing reassignment. Unlike a class object, which may not be final and can change, this provides stability. It can also be used in synchronized blocks to manage thread safety. This approach enhances clarity and control in method interactions.",
            "questionRu": "Какие преимущества передачи ‘this’ в метод вместо самого объекта класса?",
            "answerRu": "Передача this в метод гарантирует ссылку на текущий объект как финальную переменную, исключая переназначение. В отличие от объекта класса, который может быть не финальным и изменяться, this обеспечивает стабильность. Оно также может использоваться в синхронизированных блоках для управления потокобезопасностью. Этот подход повышает ясность и контроль при взаимодействии методов.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 74,
            "questionEn": "What is the constructor?",
            "answerEn": "A constructor is a special method in Java used to initialize objects when they are created. It has the same name as the class and is automatically invoked during object instantiation. Constructors can set initial values for instance variables, ensuring objects start in a valid state. They may have parameters to customize initialization or be default constructors with no arguments. This mechanism supports object-oriented programming by preparing objects for use.",
            "questionRu": "Что такое конструктор?",
            "answerRu": "Конструктор — это специальный метод в Java, используемый для инициализации объектов при их создании. Он имеет то же имя, что и класс, и автоматически вызывается при создании объекта. Конструкторы могут задавать начальные значения для переменных экземпляра, обеспечивая корректное начальное состояние объектов. Они могут включать параметры для настройки инициализации или быть конструкторами по умолчанию без аргументов. Этот механизм поддерживает объектно-ориентированное программирование, подготавливая объекты к использованию.",
            "category": "Object-Oriented Programming (OOP)",
            "level": "Junior"
        },
        {
            "id": 75,
            "questionEn": "What happens if you don’t provide a constructor in a class?",
            "answerEn": "If you don’t provide a constructor in a Java class, the compiler automatically generates a default constructor. This default constructor has no arguments and performs no operations, simply initializing the object. It assigns default values to instance variables, such as 0 for integers or null for objects. However, if you define any constructor, the default constructor is not generated. This ensures every class can create objects even without an explicit constructor.",
            "questionRu": "Что произойдет, если не указать конструктор в классе?",
            "answerRu": "Если в классе Java не указан конструктор, компилятор автоматически создает конструктор по умолчанию. Этот конструктор не принимает аргументов и не выполняет операций, просто инициализируя объект. Он присваивает переменным экземпляра значения по умолчанию, например, 0 для целых чисел или null для объектов. Однако, если вы определите любой конструктор, конструктор по умолчанию не создается. Это гарантирует, что каждый класс может создавать объекты даже без явного конструктора.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 76,
            "questionEn": "How many types of constructors are used in Java?",
            "answerEn": "Java supports two types of constructors: default and parameterized. A default constructor takes no parameters and initializes object attributes with default values. A parameterized constructor accepts arguments to assign specific values to instance variables during object creation. The default constructor is automatically provided by the compiler if no constructor is defined. These constructors enhance object initialization flexibility in Java.",
            "questionRu": "Сколько типов конструкторов используется в Java?",
            "answerRu": "В Java используются два типа конструкторов: по умолчанию и параметризованный. Конструктор по умолчанию не принимает параметров и инициализирует атрибуты объекта значениями по умолчанию. Параметризованный конструктор принимает аргументы для назначения конкретных значений переменным экземпляра при создании объекта. Конструктор по умолчанию автоматически создается компилятором, если конструктор не определен. Эти конструкторы повышают гибкость инициализации объектов в Java.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 77,
            "questionEn": "What is the purpose of a default constructor?",
            "answerEn": "Constructors help to create instances of a class or can be said to create objects of a class. Constructor is called during the initialization of objects. A default constructor is a type of constructor which do not accept any parameter, so whatever value is assigned to properties of the objects are considered default values.",
            "questionRu": "Какова цель стандартного конструктора?",
            "answerRu": "Конструкторы помогают создавать экземпляры класса или, другими словами, создавать объекты класса. Конструктор вызывается во время инициализации объектов. Конструктор по умолчанию — это тип конструктора, который не принимает параметров, поэтому значения, присваиваемые свойствам объектов, считаются значениями по умолчанию.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 78,
            "questionEn": "What do you understand by copy constructor in Java?",
            "answerEn": "A copy constructor in Java is a constructor that creates a new object by copying the properties of an existing object passed as a parameter. It initializes the new object with the same values as the given object, effectively creating a duplicate. This type of constructor is useful for cloning objects without modifying the original. Unlike languages like C++, Java does not provide a default copy constructor, so it must be explicitly defined. It is commonly used for creating independent copies of objects in a class.",
            "questionRu": "Что вы понимаете под копирующим конструктором в Java?",
            "answerRu": "Копирующий конструктор в Java — это конструктор, который создает новый объект, копируя свойства существующего объекта, переданного в качестве параметра. Он инициализирует новый объект теми же значениями, что и переданный, фактически создавая дубликат. Такой конструктор полезен для клонирования объектов без изменения оригинала. В отличие от языков, таких как C++, в Java нет встроенного копирующего конструктора, поэтому его нужно явно определять. Он часто используется для создания независимых копий объектов в классе.",
            "category": "Object-Oriented Programming (OOP)",
            "level": "Junior"
        },
        {
            "id": 79,
            "questionEn": "Where and how can you use a private constructor?",
            "answerEn": "A private constructor in Java restricts object creation by preventing direct instantiation from outside the class. It is used to control object creation, often in design patterns like Singleton, where only one instance is needed. The private constructor ensures that subclasses cannot be created, enforcing encapsulation. You can access the instance through a static factory method, such as getInstance(), which manages object creation. This approach is ideal for utility classes or controlled resource access.",
            "questionRu": "Где и как можно использовать приватный конструктор?",
            "answerRu": "Приватный конструктор в Java ограничивает создание объектов, запрещая прямую инстанциацию извне класса. Он используется для контроля создания объектов, например, в шаблонах проектирования, таких как Singleton, где нужен только один экземпляр. Приватный конструктор предотвращает создание подклассов, обеспечивая инкапсуляцию. Доступ к экземпляру возможен через статический фабричный метод, например getInstance(), который управляет созданием объекта. Этот подход идеален для утилитных классов или контролируемого доступа к ресурсам.",
            "category": "Design Patterns",
            "level": "Junior"
        },
        {
            "id": 80,
            "questionEn": "What are the differences between the constructors and methods?",
            "answerEn": "Java constructors are used for initializing objects, called only during object creation to set initial attributes. In contrast, methods can be invoked multiple times throughout an object’s lifecycle to perform specific actions. Constructors lack a return type, while methods have a return type, which can be void or another type. Constructors focus on setting up the initial state, whereas methods are designed for executing operations.",
            "questionRu": "Чем отличаются конструкторы от методов?",
            "answerRu": "Конструкторы в Java используются для инициализации объектов, вызываясь только при создании объекта для установки начальных атрибутов. В отличие от них, методы могут вызываться многократно в течение жизненного цикла объекта для выполнения конкретных действий. Конструкторы не имеют возвращаемого типа, тогда как методы имеют возвращаемый тип, который может быть void или другим типом. Конструкторы сосредоточены на установке начального состояния, а методы предназначены для выполнения операций.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 81,
            "questionEn": "What is an Interface?",
            "answerEn": "An interface in Java is a collection of abstract methods and static final variables that define a contract for implementing classes. It specifies the behavior that classes must provide without dictating the implementation details. Any class implementing an interface must override its abstract methods to fulfill the contract. Interfaces promote code reusability and enable polymorphism in object-oriented design. They are widely used to establish common APIs across different classes.",
            "questionRu": "Что такое интерфейс?",
            "answerRu": "Интерфейс в Java — это набор абстрактных методов и статических финальных переменных, определяющих контракт для реализующих классов. Он указывает поведение, которое классы должны предоставлять, не задавая деталей реализации. Любой класс, реализующий интерфейс, должен переопределить его абстрактные методы для выполнения контракта. Интерфейсы способствуют повторному использованию кода и позволяют реализовать полиморфизм в объектно-ориентированном дизайне. Они широко применяются для создания общих API между различными классами.",
            "category": "Object-Oriented Programming (OOP)",
            "level": "Junior"
        },
        {
            "id": 82,
            "questionEn": "Give some features of the Interface.",
            "answerEn": "An interface in Java is an abstract type that defines a blueprint for class behavior, containing static constants and abstract methods. It enables total abstraction by specifying what a class must do without implementation details. Interfaces support multiple inheritance, allowing a class to implement several interfaces despite extending only one class. They also promote loose coupling by separating interface from implementation. These features enhance flexibility and modularity in Java.",
            "questionRu": "Назови некоторые особенности интерфейса.",
            "answerRu": "Интерфейс в Java — это абстрактный тип, определяющий шаблон поведения класса, содержащий статические константы и абстрактные методы. Он обеспечивает полную абстракцию, указывая, что должен делать класс, не вдаваясь в детали реализации. Интерфейсы поддерживают множественное наследование, позволяя классу реализовывать несколько интерфейсов, несмотря на возможность расширения только одного класса. Они также способствуют слабой связанности, разделяя интерфейс и реализацию. Эти особенности повышают гибкость и модульность в Java.",
            "category": "Object-Oriented Programming (OOP)",
            "level": "Junior"
        },
        {
            "id": 83,
            "questionEn": "What is a marker interface?",
            "answerEn": "A marker interface in Java is an empty interface with no fields or methods, used to tag classes for specific functionality. Examples include Serializable, Cloneable, and Remote interfaces, which signal JVM or libraries to enable certain behaviors. It provides metadata about a class without requiring method implementations. Marker interfaces are often used for type checking or to grant special permissions at runtime. They are a simple way to mark classes for specialized handling.",
            "questionRu": "Что такое маркерный интерфейс?",
            "answerRu": "Маркерный интерфейс в Java — это пустой интерфейс без полей и методов, используемый для маркировки классов под определенную функциональность. Примеры включают интерфейсы Serializable, Cloneable и Remote, которые сигнализируют JVM или библиотекам о включении определенных поведений. Он предоставляет метаданные о классе без необходимости реализации методов. Маркерные интерфейсы часто применяются для проверки типов или предоставления специальных разрешений во время выполнения. Это простой способ пометить классы для особой обработки.",
            "category": "Object-Oriented Programming (OOP)",
            "level": "Junior"
        },
        {
            "id": 84,
            "questionEn": "What are the differences between abstract class and interface?",
            "answerEn": "An abstract class can contain both abstract and non-abstract methods, while an interface only has abstract methods. Abstract classes use the \"abstract\" keyword and support multiple access modifiers like private or protected, whereas interfaces use the \"interface\" keyword with public members by default. An abstract class does not support multiple inheritance, but an interface does, allowing a class to implement multiple interfaces. Abstract classes are extended using the \"extend\" keyword, while interfaces are implemented using \"implements.\" These differences make abstract classes suitable for shared code and interfaces for defining contracts.",
            "questionRu": "Чем отличается абстрактный класс от интерфейса?",
            "answerRu": "Абстрактный класс может содержать как абстрактные, так и неабстрактные методы, тогда как интерфейс имеет только абстрактные методы. Абстрактные классы объявляются с ключевым словом \"abstract\" и поддерживают разные модификаторы доступа, такие как private или protected, а интерфейсы объявляются с \"interface\" и имеют члены public по умолчанию. Абстрактный класс не поддерживает множественное наследование, но интерфейс позволяет классу реализовывать несколько интерфейсов. Абстрактные классы расширяются с помощью \"extend\", а интерфейсы реализуются через \"implements\". Эти различия делают абстрактные классы подходящими для общего кода, а интерфейсы — для определения контрактов.",
            "category": "Object-Oriented Programming (OOP)",
            "level": "Junior"
        },
        {
            "id": 85,
            "questionEn": "What do you mean by data encapsulation?",
            "answerEn": "Data encapsulation in Java is an OOP concept that bundles data and the methods operating on it within a single class. It is achieved by declaring instance variables as private, restricting direct access from outside the class. This ensures data integrity by allowing controlled access through public methods like getters and setters. Encapsulation hides the internal implementation, enhancing security and maintainability. It is a fundamental principle of object-oriented design in Java.",
            "questionRu": "Что означает инкапсуляция данных?",
            "answerRu": "Инкапсуляция данных в Java — это концепция ООП, объединяющая данные и методы, работающие с ними, в одном классе. Она достигается путем объявления переменных экземпляра как private, ограничивая прямой доступ извне класса. Это обеспечивает целостность данных, предоставляя контролируемый доступ через публичные методы, такие как геттеры и сеттеры. Инкапсуляция скрывает внутреннюю реализацию, повышая безопасность и поддерживаемость. Это основополагающий принцип объектно-ориентированного дизайна в Java.",
            "category": "Object-Oriented Programming (OOP)",
            "level": "Junior"
        },
        {
            "id": 86,
            "questionEn": "What are the advantages of Encapsulation in Java?",
            "answerEn": "Encapsulation in Java enables data hiding by restricting direct access to class fields, concealing implementation details. It increases flexibility by allowing fields to be read-only or write-only via getters and setters. This improves reusability, making code adaptable to new requirements. It also simplifies unit testing by isolating functionality.",
            "questionRu": "Какие преимущества инкапсуляции в Java?",
            "answerRu": "Инкапсуляция в Java обеспечивает сокрытие данных, ограничивая прямой доступ к полям класса и скрывая детали реализации. Она повышает гибкость, позволяя делать поля доступными только для чтения или записи через геттеры и сеттеры. Это улучшает повторное использование, упрощая адаптацию кода к новым требованиям. Также упрощает модульное тестирование за счет изоляции функциональности.",
            "category": "Object-Oriented Programming (OOP)",
            "level": "Junior"
        },
        {
            "id": 87,
            "questionEn": "What is the primary benefit of Encapsulation?",
            "answerEn": "The primary benefit of encapsulation in Java is protecting the internal state of an object from unauthorized modification or external access. It hides implementation details by exposing only a public interface, such as getter and setter methods, for interaction. This control ensures data integrity and allows managed state changes while preventing direct manipulation. Encapsulation enhances security and simplifies maintenance by isolating the object’s internal logic. It is a cornerstone of object-oriented programming in Java.",
            "questionRu": "Какова главная выгода инкапсуляции?",
            "answerRu": "Основное преимущество инкапсуляции в Java — защита внутреннего состояния объекта от несанкционированного изменения или внешнего доступа. Она скрывает детали реализации, предоставляя только публичный интерфейс, например, методы геттеры и сеттеры, для взаимодействия. Такой контроль обеспечивает целостность данных и позволяет управлять изменениями состояния, предотвращая прямое вмешательство. Инкапсуляция повышает безопасность и упрощает поддержку, изолируя внутреннюю логику объекта. Это основа объектно-ориентированного программирования в Java.",
            "category": "Object-Oriented Programming (OOP)",
            "level": "Junior"
        },
        {
            "id": 88,
            "questionEn": "What do you mean by aggregation?",
            "answerEn": "Aggregation in Java refers to a \"has-a\" relationship between two classes, representing a specialized form of association. It is a unidirectional, one-way relationship where one class holds a reference to another. The container class is said to own the referenced class, but the latter can exist independently. For example, a Car class may have an Engine object, demonstrating aggregation. This relationship promotes code reusability while maintaining loose coupling.",
            "questionRu": "Что означает агрегация?",
            "answerRu": "Агрегация в Java — это отношение типа \"имеет\" между двумя классами, представляющее специализированную форму ассоциации. Это однонаправленное, одностороннее отношение, где один класс содержит ссылку на другой. Класс-контейнер считается владельцем ссылочного класса, но последний может существовать независимо. Например, класс Car может содержать объект Engine, демонстрируя агрегацию. Это отношение способствует повторному использованию кода, сохраняя слабую связанность.",
            "category": "Object-Oriented Programming (OOP)",
            "level": "Junior"
        },
        {
            "id": 89,
            "questionEn": "What is the ‘IS-A’ relationship in OOPs Java?",
            "answerEn": "The 'IS-A' relationship in OOP Java represents inheritance, where one class inherits properties and behaviors from another. It indicates that a subclass is a type of the superclass, enabling code reuse. For example, a Dog class can inherit from an Animal class, implying a Dog is an Animal. This relationship supports polymorphism and hierarchical class design in Java. It is implemented using the \"extends\" keyword.",
            "questionRu": "Что такое отношение ‘IS-A’ в ООП Java?",
            "answerRu": "Отношение 'IS-A' в ООП Java означает наследование, при котором один класс наследует свойства и поведение другого. Оно указывает, что подкласс является типом суперкласса, что позволяет повторно использовать код. Например, класс Dog может наследовать класс Animal, подразумевая, что собака — это животное. Это отношение поддерживает полиморфизм и иерархический дизайн классов в Java. Оно реализуется с помощью ключевого слова \"extends\".",
            "category": "Object-Oriented Programming (OOP)",
            "level": "Junior"
        },
        {
            "id": 90,
            "questionEn": "Define Inheritance.",
            "answerEn": "When an object that belongs to a subclass acquires all the properties and behavior of a parent object that is from the superclass, it is known as inheritance. A class within a class is called the subclass and the latter is referred to as the superclass. Subclass or the child class is said to be specific whereas the superclass or the parent class is generic. Inheritance provides code reusability.",
            "questionRu": "Определи наследование.",
            "answerRu": "Когда объект подкласса наследует все свойства и поведение объекта родителя из суперкласса, это называется наследованием. Класс внутри класса называется подклассом, а последний — суперклассом. Подкласс или дочерний класс считается специфичным, тогда как суперкласс или родительский класс — общим. Наследование обеспечивает повторное использование кода.",
            "category": "Object-Oriented Programming (OOP)",
            "level": "Junior"
        },
        {
            "id": 91,
            "questionEn": "What are the different types of inheritance in Java?",
            "answerEn": "Inheritance in Java allows a subclass to inherit features from a superclass, existing in four types. Single inheritance occurs when a subclass extends one superclass, passing its properties to the child class. Multilevel inheritance creates a hierarchy where a subclass extends another subclass. Hierarchical inheritance involves multiple subclasses deriving from a single superclass. Multiple inheritance, supported only through interfaces in Java, enables a class to inherit from multiple parent interfaces.",
            "questionRu": "Какие типы наследования есть в Java?",
            "answerRu": "Наследование в Java позволяет подклассу наследовать свойства суперкласса и существует в четырех типах. Одиночное наследование возникает, когда подкласс расширяет один суперкласс, передавая свои свойства дочернему классу. Многоуровневое наследование создает иерархию, где подкласс расширяет другой подкласс. Иерархическое наследование подразумевает, что несколько подклассов наследуют один суперкласс. Множественное наследование, поддерживаемое в Java только через интерфейсы, позволяет классу наследовать несколько родительских интерфейсов.",
            "category": "Object-Oriented Programming (OOP)",
            "level": "Junior"
        },
        {
            "id": 92,
            "questionEn": "What is multiple inheritance? Is it supported by Java?",
            "answerEn": "Multiple inheritance in OOP allows a class to inherit properties and behaviors from multiple parent classes. It can lead to ambiguity when methods with the same signature exist in different parent classes, complicating method resolution. Java does not support multiple inheritance of classes to avoid such issues, known as the \"diamond problem.\" However, Java supports multiple inheritance through interfaces, allowing a class to implement multiple interfaces. This approach provides a safer way to achieve flexibility in class design.",
            "questionRu": "Что такое множественное наследование? Поддерживает ли его Java?",
            "answerRu": "Множественное наследование в ООП позволяет классу наследовать свойства и поведение от нескольких родительских классов. Это может привести к неоднозначности, если методы с одинаковой сигнатурой есть в разных родительских классах, усложняя выбор метода. Java не поддерживает множественное наследование классов, чтобы избежать проблем, известных как \"проблема ромба\". Однако Java поддерживает множественное наследование через интерфейсы, позволяя классу реализовывать несколько интерфейсов. Этот подход обеспечивает более безопасный способ достижения гибкости в проектировании классов.",
            "category": "Object-Oriented Programming (OOP)",
            "level": "Junior"
        },
        {
            "id": 93,
            "questionEn": "How is inheritance in C++ different from Java?",
            "answerEn": "nheritance in C++ differs from Java in several key ways. C++ supports multiple inheritance, allowing a class to inherit from multiple parent classes, while Java does not support this for classes to avoid complexity. In Java, all classes implicitly inherit from the Object class, forming a single inheritance hierarchy. In contrast, C++ classes do not inherit from a universal base class like Object, existing independently. These differences reflect Java’s focus on simplicity and safety compared to C++’s flexibility.",
            "questionRu": "Чем отличается наследование в C++ от Java?",
            "answerRu": "Наследование в C++ отличается от Java по нескольким ключевым аспектам. C++ поддерживает множественное наследование, позволяя классу наследовать несколько родительских классов, тогда как Java не поддерживает это для классов, чтобы избежать сложностей. В Java все классы неявно наследуются от класса Object, формируя единую иерархию наследования. В отличие от этого, классы в C++ не наследуются от универсального базового класса, такого как Object, существуя независимо. Эти различия отражают акцент Java на простоте и безопасности по сравнению с гибкостью C++.",
            "category": "Object-Oriented Programming (OOP)",
            "level": "Junior"
        },
        {
            "id": 94,
            "questionEn": "Is there any limitation to using Inheritance?",
            "answerEn": "Yes, inheritance in Java has limitations that can impact code quality. It can lead to a cluttered subclass by inheriting all properties from a superclass or interface, increasing complexity. This clustering may cause errors, especially with dynamic overriding or overloading in certain scenarios. Additionally, tight coupling between classes can reduce flexibility and make maintenance harder. These limitations highlight the need for careful design when using inheritance.",
            "questionRu": "Есть ли ограничения у использования наследования?",
            "answerRu": "Да, наследование в Java имеет ограничения, которые могут повлиять на качество кода. Оно может привести к перегруженному подклассу, наследующему все свойства суперкласса или интерфейса, что увеличивает сложность. Такая перегруженность может вызывать ошибки, особенно при динамическом переопределении или перегрузке в определенных сценариях. Кроме того, сильная связанность между классами может снизить гибкость и усложнить поддержку. Эти ограничения подчеркивают необходимость тщательного проектирования при использовании наследования.",
            "category": "Object-Oriented Programming (OOP)",
            "level": "Junior"
        },
        {
            "id": 95,
            "questionEn": "Although inheritance is a popular OOPs concept, it is less advantageous than composition. Explain.",
            "answerEn": "Although inheritance is a popular OOP concept where a subclass inherits properties and methods from a superclass, composition is often more advantageous. Inheritance can lead to tight coupling, where changes in a superclass affect all subclasses, reducing flexibility and complicating maintenance. It also causes the fragile base class problem, where modifications to the base class break derived class functionality. Additionally, inheritance may result in limited reuse and code duplication due to inheriting unnecessary methods. Composition, by using member objects, offers greater flexibility and avoids these issues.",
            "questionRu": "Почему наследование, популярная концепция ООП, менее выгодно, чем композиция?",
            "answerRu": "Хотя наследование — популярная концепция ООП, где подкласс наследует свойства и методы суперкласса, композиция часто оказывается более выгодной. Наследование может привести к сильной связанности, когда изменения в суперклассе влияют на все подклассы, снижая гибкость и усложняя поддержку. Оно также вызывает проблему хрупкого базового класса, когда изменения в базовом классе нарушают функциональность производных классов. Кроме того, наследование может привести к ограниченному повторному использованию и дублированию кода из-за наследования ненужных методов. Композиция, используя объекты-члены, обеспечивает большую гибкость и избегает этих проблем.",
            "category": "Object-Oriented Programming (OOP)",
            "level": "Junior"
        },
        {
            "id": 96,
            "questionEn": "What is an association?",
            "answerEn": "An association is a relationship between two separate classes established through their objects, representing a \"has-a\" relationship. It indicates that one class can use or contain instances of another class without ownership. For example, a University class may have an association with a Student class, where a university has students. This relationship supports flexibility and is a fundamental concept in object-oriented design. It differs from inheritance by not involving a hierarchical structure.",
            "questionRu": "Что такое ассоциация?",
            "answerRu": "Ассоциация — это отношение между двумя отдельными классами, устанавливаемое через их объекты, представляющее отношение \"имеет\". Оно указывает, что один класс может использовать или содержать экземпляры другого класса без владения ими. Например, класс University может иметь ассоциацию с классом Student, где университет имеет студентов. Это отношение поддерживает гибкость и является основополагающим понятием в объектно-ориентированном дизайне. Оно отличается от наследования отсутствием иерархической структуры.",
            "category": "Object-Oriented Programming (OOP)",
            "level": "Junior"
        },
        {
            "id": 97,
            "questionEn": "What do you mean by aggregation?",
            "answerEn": "Aggregation refers to a \"has-a\" relationship between two classes, where one class contains a reference to another without strict ownership. It is a unidirectional association, allowing the referenced class to exist independently. Unlike composition, aggregation represents a weaker dependency, such as a University having Students who can exist outside the university. This relationship promotes flexibility and code reusability in object-oriented design. It differs from composition, which implies a stronger, life-cycle dependency.",
            "questionRu": "Что вы имеете в виду под агрегацией?",
            "answerRu": "Агрегация — это отношение \"имеет\" между двумя классами, где один класс содержит ссылку на другой без строгого владения. Это однонаправленная ассоциация, позволяющая ссылочному классу существовать независимо. В отличие от композиции, агрегация представляет более слабую зависимость, например, университет, имеющий студентов, которые могут существовать вне университета. Это отношение способствует гибкости и повторному использованию кода в объектно-ориентированном дизайне. Она отличается от композиции, которая предполагает более сильную зависимость жизненного цикла.",
            "category": "Object-Oriented Programming (OOP)",
            "level": "Junior"
        },
        {
            "id": 98,
            "questionEn": "What is the composition of Java?",
            "answerEn": "Composition in Java is a strong \"part-of\" relationship where the child object cannot exist independently of the parent object. It represents a strict dependency, meaning the child’s lifecycle is tied to the parent’s lifecycle. For example, a Human class may compose a Heart object, as the heart cannot exist without the human. This relationship ensures tight coupling and is used to model whole-part hierarchies. Composition enhances encapsulation by managing dependent objects within a single unit.",
            "questionRu": "Что такое композиция в Java?",
            "answerRu": "Композиция в Java — это строгое отношение \"часть-целое\", где дочерний объект не может существовать независимо от родительского объекта. Она представляет строгую зависимость, при которой жизненный цикл дочернего объекта связан с жизненным циклом родителя. Например, класс Human может включать объект Heart, поскольку сердце не может существовать без человека. Это отношение обеспечивает тесную связанность и используется для моделирования иерархий \"целое-часть\". Композиция улучшает инкапсуляцию, управляя зависимыми объектами в едином модуле.",
            "category": "Object-Oriented Programming (OOP)",
            "level": "Junior"
        },
        {
            "id": 99,
            "questionEn": "State the difference between Composition and Aggregation.",
            "answerEn": "Aggregation defines a \"has-a\" relationship where objects are independent, represented by an empty diamond in UML. Composition represents a \"part-of\" relationship with dependent objects, depicted by a filled diamond. In aggregation, child objects can exist independently, while in composition, their lifetime is tied to the parent object. This distinction highlights aggregation’s flexibility versus composition’s stronger coupling. Both are key concepts in object-oriented design for managing relationships.",
            "questionRu": "Укажи разницу между композицией и агрегацией.",
            "answerRu": "Агрегация определяет отношение \"имеет\", где объекты независимы, что отображается пустым ромбом в UML. Композиция представляет отношение \"часть-целое\" с зависимыми объектами, изображаемое заполненным ромбом. В агрегации дочерние объекты могут существовать самостоятельно, тогда как в композиции их жизненный цикл связан с родительским объектом. Это различие подчеркивает гибкость агрегации по сравнению с более сильной связанностью композиции. Оба понятия являются ключевыми в объектно-ориентированном дизайне для управления отношениями.",
            "category": "Object-Oriented Programming (OOP)",
            "level": "Junior"
        },
        {
            "id": 100,
            "questionEn": "Can the constructor be inherited?",
            "answerEn": "No, a constructor cannot be inherited in Java because it is not a regular method. Constructors are special methods used to initialize objects and are tied to their specific class. When a subclass is created, it does not inherit the superclass’s constructor, but it can call it using the \"super\" keyword. If no constructor is defined in the subclass, Java provides a default constructor that implicitly calls the superclass’s constructor. This design ensures proper object initialization for each class in the hierarchy.",
            "questionRu": "Может ли конструктор быть унаследован?",
            "answerRu": "Нет, конструктор не может быть унаследован в Java, поскольку он не является обычным методом. Конструкторы — это специальные методы, используемые для инициализации объектов и привязанные к своему классу. Когда создается подкласс, он не наследует конструктор суперкласса, но может вызвать его с помощью ключевого слова \"super\". Если в подклассе не определен конструктор, Java предоставляет конструктор по умолчанию, который неявно вызывает конструктор суперкласса. Такой подход обеспечивает правильную инициализацию объектов для каждого класса в иерархии.",
            "category": "Object-Oriented Programming (OOP)",
            "level": "Junior"
        },
        {
            "id": 101,
            "questionEn": "What is Polymorphism?",
            "answerEn": "Polymorphism is the ability of an object to take multiple forms, a core concept in OOP. It is divided into two types: compile-time polymorphism, achieved through method overloading where multiple methods share the same name but differ in parameters. Run-time polymorphism, or method overriding, occurs when a subclass provides a specific implementation of a method from its parent class, resolved during execution. This flexibility allows code to handle different data types and behaviors seamlessly. Polymorphism enhances extensibility and maintainability in Java applications.",
            "questionRu": "Что такое полиморфизм?",
            "answerRu": "Полиморфизм — это способность объекта принимать различные формы, являясь ключевым понятием ООП. Он делится на два типа: полиморфизм времени компиляции, достигаемый через перегрузку методов, когда несколько методов имеют одно имя, но отличаются по параметрам. Полиморфизм времени выполнения, или переопределение метода, происходит, когда подкласс предоставляет конкретную реализацию метода родительского класса, разрешаемую во время выполнения. Эта гибкость позволяет коду обрабатывать различные типы данных и поведения плавно. Полиморфизм повышает расширяемость и поддерживаемость приложений Java.",
            "category": "Object-Oriented Programming (OOP)",
            "level": "Junior"
        },
        {
            "id": 102,
            "questionEn": "What is runtime polymorphism or dynamic method dispatch?",
            "answerEn": "Runtime polymorphism, or dynamic method dispatch, is a mechanism in Java that resolves method overriding during execution. It occurs when a subclass provides the same method name, parameters, and return type as in the superclass. When called through a superclass reference, Java determines at runtime which method—superclass or subclass— to execute based on the object’s type. This dynamic resolution enables flexibility and supports the core principles of object-oriented programming. It is a key feature for achieving polymorphic behavior in inheritance.",
            "questionRu": "Что такое полиморфизм времени выполнения или динамическая диспетчеризация методов?",
            "answerRu": "Полиморфизм времени выполнения, или динамическое разрешение методов, — это механизм в Java, который разрешает переопределение методов во время выполнения. Он происходит, когда подкласс предоставляет метод с тем же именем, параметрами и типом возвращаемого значения, что и в супер классе. При вызове через ссылку суперкласса Java определяет во время выполнения, какой метод — суперкласса или подкласса — выполнить, основываясь на типе объекта. Это динамическое разрешение обеспечивает гибкость и поддерживает основные принципы объектно-ориентированного программирования. Это ключевой элемент для достижения полиморфного поведения в наследовании.",
            "category": "Object-Oriented Programming (OOP)",
            "level": "Junior"
        },
        {
            "id": 103,
            "questionEn": "What is method overriding?",
            "answerEn": "Method overriding is a feature in Java where a subclass provides a specific implementation of a method already defined in its superclass. It requires the method in the subclass to have the same name, parameters, and return type (or a subtype) as the method in the superclass. When this method is called on a subclass object, the overridden version in the subclass is executed instead of the superclass version. This mechanism enables runtime polymorphism, allowing dynamic behavior based on the object’s type. For example, if a parent class has a method gfg() and the subclass redefines it, the subclass’s gfg() is invoked.",
            "questionRu": "Что такое переопределение метода?",
            "answerRu": "Переопределение метода — это функция в Java, при которой подкласс предоставляет свою реализацию метода, уже определенного в супер-классе. Метод в подклассе должен иметь то же имя, параметры и тип возвращаемого значения (или его подтип), что и метод в супер-классе. Когда этот метод вызывается на объекте подкласса, выполняется переопределенная версия из подкласса, а не версия из супер-класса. Этот механизм обеспечивает полиморфизм времени выполнения, позволяя динамическое поведение в зависимости от типа объекта. Например, если в родительском классе есть метод gfg(), а подкласс его переопределяет, вызывается версия gfg() из подкласса.",
            "category": "Object-Oriented Programming (OOP)",
            "level": "Junior"
        },
        {
            "id": 104,
            "questionEn": "What is method overloading?",
            "answerEn": "Method overloading in Java allows multiple methods to share the same name but differ in their signatures, defined by the number or type of parameters. This feature, also known as compile-time polymorphism or static polymorphism, resolves method calls during compilation based on the provided arguments. For example, a class can have methods like add(int a, int b) and add(double a, double b) distinguished by parameter types. It enhances code readability and flexibility by grouping related functionality under one name. The method with the most specific parameter type matching the arguments gets priority during resolution.",
            "questionRu": "Что такое перегрузка метода?",
            "answerRu": "Перегрузка методов в Java позволяет нескольким методам иметь одно имя, но отличаться сигнатурами, определяемыми количеством или типом параметров. Эта функция, известная как полиморфизм времени компиляции или статический полиморфизм, разрешает вызовы методов на этапе компиляции на основе переданных аргументов. Например, класс может содержать методы add(int a, int b) и add(double a, double b), различающиеся типами параметров. Это улучшает читаемость и гибкость кода, объединяя связанную функциональность под одним именем. Метод с наиболее подходящим типом параметров, соответствующим аргументам, получает приоритет при разрешении.",
            "category": "Object-Oriented Programming (OOP)",
            "level": "Junior"
        },
        {
            "id": 105,
            "questionEn": "Can we override the static method?",
            "answerEn": "Static methods in Java cannot be overridden because they belong to the class, not to an instance of the class. Overriding relies on instance-based polymorphism, which resolves method calls at runtime based on the object’s type. Since static methods are bound to the class and resolved at compile time, they do not participate in this dynamic dispatch. However, a subclass can declare a static method with the same name, but this is called hiding, not overriding. For example, if a parent class has a static method print(), the subclass’s print() will hide it rather than override it.",
            "questionRu": "Можно ли переопределить статический метод?",
            "answerRu": "Статические методы в Java нельзя переопределить, потому что они принадлежат классу, а не экземпляру класса. Переопределение основано на полиморфизме экземпляров, который разрешает вызовы методов во время выполнения на основе типа объекта. Поскольку статические методы привязаны к классу и разрешаются на этапе компиляции, они не участвуют в динамическом диспетчеризации. Однако подкласс может объявить статический метод с тем же именем, но это называется сокрытием, а не переопределением. Например, если в родительском классе есть статический метод print(), метод print() в подклассе будет его скрывать, а не переопределять.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 106,
            "questionEn": "Can we override the overloaded method?",
            "answerEn": "Yes, an overloaded method can be overridden because the compiler treats each overloaded method as distinct based on its signature. Method overloading involves different parameter lists, while overriding requires the same signature in a subclass. When a subclass overrides an overloaded method, the decision on which version to execute is made at runtime, based on the object’s type. For example, if a parent class has doWork(int a) and doWork(String s), a subclass can override either or both. This combines compile-time resolution for overloading with runtime polymorphism for overriding.",
            "questionRu": "Можно ли переопределить перегруженный метод?",
            "answerRu": "Да, перегруженный метод можно переопределить, потому что компилятор рассматривает каждый перегруженный метод как отдельный на основе его сигнатуры. Перегрузка методов предполагает разные списки параметров, тогда как переопределение требует одинаковую сигнатуру в подклассе. Когда подкласс переопределяет перегруженный метод, выбор версии для выполнения происходит во время выполнения на основе типа объекта. Например, если родительский класс имеет методы doWork(int a) и doWork(String s), подкласс может переопределить один или оба. Это сочетает разрешение на этапе компиляции для перегрузки с полиморфизмом времени выполнения для переопределения.",
            "category": "Object-Oriented Programming (OOP)",
            "level": "Junior"
        },
        {
            "id": 107,
            "questionEn": "Can we overload the main() method?",
            "answerEn": "Yes, in Java, the main() method can be overloaded by defining additional versions with different parameter lists. The original main(String[] args) serves as the entry point for the JVM, but other variants like main(int a) or main(String s) can coexist. These overloaded versions are treated as separate methods and can be called explicitly from within the program. However, only the standard main(String[] args) is automatically invoked by the JVM at runtime. For example, you can define main(int a) and call it manually, but it won’t start the program.",
            "questionRu": "Можно ли перегрузить метод main()?",
            "answerRu": "Да, в Java метод main() можно перегрузить, определив дополнительные версии с разными списками параметров. Оригинальный main(String[] args) является точкой входа для JVM, но другие варианты, такие как main(int a) или main(String s), могут существовать параллельно. Эти перегруженные версии рассматриваются как отдельные методы и могут быть вызваны явно внутри программы. Однако только стандартный main(String[] args) автоматически вызывается JVM во время выполнения. Например, можно определить main(int a) и вызвать его вручную, но он не запустит программу.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 108,
            "questionEn": "What are method overloading and method overriding?",
            "answerEn": "Method overloading allows multiple methods in the same class to share the same name but differ in their parameter lists, enabling compile-time polymorphism. For example, multiply(int a, int b) and multiply(int a, int b, int c) are resolved at compile time based on the arguments. Method overriding occurs when a subclass redefines a superclass method with the same name, parameters, and return type, supporting runtime polymorphism. For instance, a Vehicle class’s drive() can be overridden by a Car class, and the call is resolved at runtime based on the object type. Overloading enhances flexibility within a class, while overriding enables specialized behavior in inheritance.",
            "questionRu": "Что такое перегрузка и переопределение методов?",
            "answerRu": "Перегрузка методов позволяет нескольким методам в одном классе иметь одинаковое имя, но разные списки параметров, обеспечивая полиморфизм времени компиляции. Например, multiply(int a, int b) и multiply(int a, int b, int c) разрешаются на этапе компиляции по аргументам. Переопределение методов происходит, когда подкласс переопределяет метод суперкласса с тем же именем, параметрами и типом возвращаемого значения, поддерживая полиморфизм времени выполнения. Например, метод drive() класса Vehicle может быть переопределён классом Car, и вызов разрешается во время выполнения по типу объекта. Перегрузка повышает гибкость внутри класса, а переопределение обеспечивает специализированное поведение в наследовании.",
            "category": "Object-Oriented Programming (OOP)",
            "level": "Junior"
        },
        {
            "id": 109,
            "questionEn": "Can we override the private methods?",
            "answerEn": "Private methods in Java cannot be overridden because they are not visible outside the class in which they are defined. Method overriding requires a subclass to provide a new implementation of a method inherited from a superclass. Since private methods are inaccessible to subclasses due to their restricted scope, they cannot be overridden. For example, a private method doWork() in a parent class remains hidden from a subclass, preventing any override attempt. Only methods with sufficient visibility, like public or protected, can be overridden.",
            "questionRu": "Можно ли переопределить приватные методы?",
            "answerRu": "Приватные методы в Java нельзя переопределить, потому что они не видны за пределами класса, в котором объявлены. Переопределение методов предполагает, что подкласс предоставляет новую реализацию метода, унаследованного от суперкласса. Поскольку приватные методы недоступны подклассам из-за их ограниченной области видимости, их нельзя переопределить. Например, приватный метод doWork() в родительском классе остаётся скрытым от подкласса, что исключает попытку переопределения. Переопределять можно только методы с достаточной видимостью, такие как public или protected.",
            "category": "Object-Oriented Programming (OOP)",
            "level": "Junior"
        },
        {
            "id": 110,
            "questionEn": "Can we change the scope of the overridden method in the subclass?",
            "answerEn": "In Java, the scope of an overridden method in a subclass cannot be more restrictive than that of the superclass method. The subclass method’s access level must be equal to or broader than the overridden method’s scope to maintain accessibility. For example, if a superclass method is public, the subclass’s overridden method can also be public, but not protected, default, or private. This rule ensures that polymorphism preserves the contract of the superclass. Attempting to narrow the scope, like changing from public to private, results in a compilation error.",
            "questionRu": "Можно ли изменить область видимости переопределенного метода в подклассе?",
            "answerRu": "В Java область видимости переопределённого метода в подклассе не может быть более строгой, чем у метода суперкласса. Уровень доступа метода в подклассе должен быть равным или шире, чем у переопределённого метода, чтобы сохранить доступность. Например, если метод суперкласса имеет модификатор public, переопределённый метод в подклассе тоже должен быть public, но не protected, default или private. Это правило гарантирует, что полиморфизм сохраняет контракт суперкласса. Попытка сузить область видимости, например, с public до private, приведёт к ошибке компиляции.",
            "category": "Object-Oriented Programming (OOP)",
            "level": "Junior"
        },
        {
            "id": 111,
            "questionEn": "Can we modify the throws clause of the superclass method while overriding it in the subclass?",
            "answerEn": "In Java, the throws clause of a superclass method can be modified when overriding it in a subclass, but with restrictions. If the superclass method declares no exceptions, the subclass method can only throw unchecked exceptions. If the superclass method throws an exception, the subclass method can throw the same exception, a more specific subclass exception, or no exception, but not a broader parent exception. For example, if a superclass method throws IOException, the subclass can throw FileNotFoundException (a subclass) but not Exception (a parent). This ensures the overridden method adheres to the superclass’s contract while allowing flexibility.",
            "questionRu": "Можно ли изменить throws в методе суперкласса при переопределении в подклассе?",
            "answerRu": "В Java при переопределении метода суперкласса можно изменить его throws-раздел, но с ограничениями. Если метод суперкласса не объявляет исключений, метод подкласса может выбрасывать только непроверяемые исключения. Если метод суперкласса объявляет исключение, метод подкласса может выбрасывать то же исключение, более специфичное исключение-подкласс или не выбрасывать ничего, но не более широкое родительское исключение. Например, если метод суперкласса выбрасывает IOException, подкласс может выбросить FileNotFoundException (подкласс), но не Exception (родитель). Это гарантирует, что переопределённый метод соответствует контракту суперкласса, сохраняя гибкость.",
            "category": "Object-Oriented Programming (OOP)",
            "level": "Junior"
        },
        {
            "id": 112,
            "questionEn": "Can you have virtual functions in Java?",
            "answerEn": "In Java, all non-static, non-final instance methods are virtual by default, meaning they support runtime polymorphism. Virtual functions allow a subclass to override a superclass method, and the method to be executed is determined at runtime based on the object’s type. For example, if a superclass has a method run() and a subclass overrides it, calling run() on a superclass reference to a subclass object invokes the subclass version. The final keyword can be used to make a method non-virtual, preventing further overriding. This behavior is fundamental to Java’s object-oriented design.",
            "questionRu": "Могут ли быть виртуальные функции в Java?",
            "answerRu": "В Java все нестатические и не помеченные как final методы экземпляра по умолчанию являются виртуальными, то есть поддерживают полиморфизм времени выполнения. Виртуальные функции позволяют подклассу переопределять метод суперкласса, а выполняемый метод определяется во время выполнения на основе типа объекта. Например, если в супер-классе есть метод run(), а подкласс его переопределяет, вызов run() через ссылку суперкласса на объект подкласса выполнит версию подкласса. Ключевое слово final делает метод невртуальным, запрещая его переопределение. Это свойство лежит в основе объектно-ориентированного дизайна Java.",
            "category": "Object-Oriented Programming (OOP)",
            "level": "Junior"
        },
        {
            "id": 113,
            "questionEn": "What is Abstraction?",
            "answerEn": "Abstraction in Java is the process of highlighting essential features of an object while hiding its implementation details. It simplifies complexity by exposing only the necessary interfaces or behaviors to the user. For example, a car driver uses controls like the steering wheel and pedals without understanding the engine’s internal mechanics. In programming, abstraction is achieved through abstract classes and interfaces, focusing on \"what\" rather than \"how.\" This approach enhances maintainability and reduces complexity in large systems.",
            "questionRu": "Что такое абстракция?",
            "answerRu": "Абстракция в Java — это процесс выделения ключевых характеристик объекта при сокрытии деталей его реализации. Она упрощает сложность, предоставляя пользователю только необходимые интерфейсы или поведение. Например, водитель автомобиля использует руль и педали, не зная внутренней механики двигателя. В программировании абстракция реализуется через абстрактные классы и интерфейсы, сосредотачиваясь на \"что\", а не на \"как.\" Этот подход повышает удобство поддержки и снижает сложность в больших системах.",
            "category": "Object-Oriented Programming (OOP)",
            "level": "Junior"
        },
        {
            "id": 114,
            "questionEn": "What is Abstract class?",
            "answerEn": "An abstract class in Java is a class declared with the abstract keyword, which cannot be instantiated directly. It serves as a blueprint for subclasses, requiring them to implement any abstract methods it declares. A class must be abstract if it contains at least one abstract method, though it can also include concrete methods. For example, an abstract class Fruits with an abstract method run() must be extended by a concrete class like Apple to provide the implementation. This mechanism enforces a structure while allowing flexibility in subclass behavior.",
            "questionRu": "Что такое абстрактный класс?",
            "answerRu": "Абстрактный класс в Java — это класс, объявленный с ключевым словом abstract, который нельзя создать напрямую. Он служит шаблоном для подклассов, требуя от них реализации всех объявленных абстрактных методов. Класс должен быть абстрактным, если содержит хотя бы один абстрактный метод, хотя может включать и конкретные методы. Например, абстрактный класс Fruits с абстрактным методом run() должен быть расширен конкретным классом, таким как Apple, для реализации. Этот механизм обеспечивает структуру, сохраняя гибкость поведения подклассов.",
            "category": "Object-Oriented Programming (OOP)",
            "level": "Junior"
        },
        {
            "id": 115,
            "questionEn": "When Abstract methods are used?",
            "answerEn": "Abstract methods are used in Java to define a method in a parent class without providing its implementation. They allow subclasses to specify how the method should behave, enforcing a contract for consistent functionality. This is useful when the parent class needs to outline a behavior, but the details depend on the specific subclass. For example, an abstract class Animal might declare an abstract method makeSound(), leaving Dog and Cat to implement it differently. Abstract methods are key to achieving flexibility and polymorphism in object-oriented design.",
            "questionRu": "Когда используются абстрактные методы?",
            "answerRu": "Абстрактные методы в Java используются для определения метода в родительском классе без указания его реализации. Они позволяют подклассам определить, как метод должен работать, обеспечивая контракт для согласованной функциональности. Это полезно, когда родительский класс должен обозначить поведение, но детали зависят от конкретного подкласса. Например, абстрактный класс Animal может объявить абстрактный метод makeSound(), оставляя реализацию Dog и Cat разной. Абстрактные методы играют ключевую роль в достижении гибкости и полиморфизма в объектно-ориентированном дизайне.",
            "category": "Object-Oriented Programming (OOP)",
            "level": "Junior"
        },
        {
            "id": 116,
            "questionEn": "How can you avoid serialization in the child class if the base class is implementing the Serializable interface?",
            "answerEn": "If a base class implements the Serializable interface, a child class can avoid serialization by overriding the writeObject() method. In this method, the child class throws a NotSerializableException to explicitly prevent the serialization process. This works because Java’s serialization mechanism invokes writeObject() during object serialization, allowing custom control. For example, a child class Child extending a serializable Parent can define private void writeObject(ObjectOutputStream out) throws IOException { throw new NotSerializableException(); }. This approach ensures the child class opts out of serialization while the base class remains serializable.",
            "questionRu": "Как избежать сериализации в дочернем классе, если базовый класс реализует Serializable?",
            "answerRu": "Если базовый класс реализует интерфейс Serializable, подкласс может избежать сериализации, переопределив метод writeObject(). В этом методе подкласс выбрасывает исключение NotSerializableException, чтобы явно предотвратить процесс сериализации. Это работает, потому что механизм сериализации Java вызывает writeObject() при сериализации объекта, предоставляя возможность пользовательского управления. Например, подкласс Child, расширяющий сериализуемый Parent, может определить private void writeObject(ObjectOutputStream out) throws IOException { throw new NotSerializableException(); }. Такой подход позволяет подклассу отказаться от сериализации, сохраняя сериализуемость базового класса.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 117,
            "questionEn": "What is Collection Framework in Java?",
            "answerEn": "The Collection Framework in Java is a unified architecture of interfaces and classes designed to store and manipulate groups of objects. It provides a standard way to handle collections, such as lists, sets, and queues, with predefined methods for operations like adding or removing elements. Key interfaces include List, Set, and Queue, each tailored to specific data organization needs. Classes like ArrayList, LinkedList, and TreeSet implement these interfaces, offering flexible and efficient data structures. This framework simplifies development by providing reusable, optimized tools for managing collections.",
            "questionRu": "Что такое Collection Framework в Java?",
            "answerRu": "Collection Framework в Java — это унифицированная архитектура интерфейсов и классов, предназначенная для хранения и управления группами объектов. Она предоставляет стандартный способ работы с коллекциями, такими как списки, множества и очереди, с предопределёнными методами для операций, вроде добавления или удаления элементов. Основные интерфейсы, такие как List, Set и Queue, адаптированы под конкретные потребности организации данных. Классы, например ArrayList, LinkedList и TreeSet, реализуют эти интерфейсы, предлагая гибкие и эффективные структуры данных. Этот фреймворк упрощает разработку, предоставляя повторно используемые и оптимизированные инструменты для управления коллекциями.",
            "category": "Collections",
            "level": "Junior"
        },
        {
            "id": 118,
            "questionEn": "Explain various interfaces used in the Collection framework.",
            "answerEn": "The Collection Framework in Java includes several key interfaces for managing object collections. The Collection interface, the root of the hierarchy, defines basic operations like adding and removing elements for all collections. The List interface supports ordered, index-based collections allowing duplicates, while the Set interface handles unordered collections without duplicates. The Queue and Deque interfaces manage elements in a specific order, typically for FIFO or LIFO processing, with Deque supporting both ends. Although not part of the Collection hierarchy, the Map interface organizes data as key-value pairs for efficient lookups.",
            "questionRu": "Объясни различные интерфейсы в Collection Framework.",
            "answerRu": "Collection Framework в Java включает несколько ключевых интерфейсов для управления коллекциями объектов. Интерфейс Collection, корень иерархии, определяет базовые операции, такие как добавление и удаление элементов для всех коллекций. Интерфейс List поддерживает упорядоченные коллекции с доступом по индексу и разрешением дубликатов, а Set управляет неупорядоченными коллекциями без дубликатов. Интерфейсы Queue и Deque организуют элементы в определённом порядке, обычно для обработки FIFO или LIFO, при этом Deque работает с обоими концами. Хотя интерфейс Map не входит в иерархию Collection, он структурирует данные как пары ключ-значение для эффективного поиска.",
            "category": "Collections",
            "level": "Junior"
        },
        {
            "id": 119,
            "questionEn": "How can you synchronize an ArrayList in Java?",
            "answerEn": "In Java, an ArrayList can be synchronized using Collections.synchronizedList() or CopyOnWriteArrayList. The Collections.synchronizedList() method wraps an existing ArrayList into a thread-safe list, synchronizing all its operations. Alternatively, CopyOnWriteArrayList is a thread-safe variant of ArrayList where modifications create a new copy of the underlying array, avoiding concurrent access issues. The first approach is simpler and suits general synchronization needs, while the second is better for read-heavy scenarios due to its copy-on-write mechanism. For example, List<String> syncList = Collections.synchronizedList(new ArrayList<>()) ensures thread safety.",
            "questionRu": "Как синхронизировать ArrayList в Java?",
            "answerRu": "В Java ArrayList можно синхронизировать с помощью Collections.synchronizedList() или CopyOnWriteArrayList. Метод Collections.synchronizedList() оборачивает существующий ArrayList в потокобезопасный список, синхронизируя все его операции. В качестве альтернативы, CopyOnWriteArrayList — это потокобезопасная версия ArrayList, где изменения создают новую копию базового массива, избегая проблем параллельного доступа. Первый подход проще и подходит для общих нужд синхронизации, тогда как второй лучше для случаев с частым чтением благодаря механизму копирования при записи. Например, List<String> syncList = Collections.synchronizedList(new ArrayList<>()) обеспечивает потокобезопасность.",
            "category": "Collections",
            "level": "Junior"
        },
        {
            "id": 120,
            "questionEn": "Why do we need a synchronized ArrayList when we have Vectors (which are synchronized) in Java?",
            "answerEn": "A synchronized ArrayList is preferred over Vectors in Java for specific reasons. ArrayList offers better performance because it isn’t synchronized by default, unlike Vectors, which synchronize every operation. While Vectors support only single-threaded use, a synchronized ArrayList can be explicitly managed in multithreaded environments using Collections.synchronizedList(). Vectors are considered legacy due to their inherent synchronization, which adds unnecessary overhead in modern applications. Thus, ArrayList provides flexibility and efficiency tailored to current programming needs.",
            "questionRu": "Зачем нужен синхронизированный ArrayList, если есть Vectors (которые синхронизированы)?",
            "answerRu": "Синхронизированный ArrayList предпочтительнее Vectors в Java по ряду причин. ArrayList обеспечивает лучшую производительность, так как по умолчанию не синхронизирован, в отличие от Vectors, где каждая операция синхронизирована. Если Vectors поддерживают только однопоточность, то синхронизированный ArrayList можно явно использовать в многопоточных средах через Collections.synchronizedList(). Vectors считаются устаревшими из-за встроенной синхронизации, которая создает лишние накладные расходы в современных приложениях. Таким образом, ArrayList предлагает гибкость и эффективность для актуальных задач программирования.",
            "category": "Collections",
            "level": "Junior"
        },
        {
            "id": 121,
            "questionEn": "Why can’t we create a generic array?",
            "answerEn": "Generic arrays cannot be created in Java due to limitations caused by type erasure. At compile time, generics are replaced with their raw types via type erasure, erasing specific type information. Arrays, however, rely on runtime type checking to ensure all elements match the declared type, throwing an ArrayStoreException if they don’t. Without generic type details at runtime, this check would fail to catch mismatches, compromising type safety. Thus, Java prohibits generic array creation to prevent such runtime errors.",
            "questionRu": "Почему нельзя создать обобщенный массив?",
            "answerRu": "Генерические массивы нельзя создать в Java из-за ограничений, связанных с удалением типов. Во время компиляции дженерики заменяются их сырыми типами через механизм удаления типов, что стирает информацию о конкретных типах. Массивы же используют проверку типов во время выполнения, чтобы гарантировать соответствие элементов объявленному типу, выбрасывая ArrayStoreException при несоответствии. Без информации о типах дженериков на этапе выполнения эта проверка не смогла бы выявить ошибки, нарушая безопасность типов. Поэтому Java запрещает создание генерических массивов, чтобы избежать таких ошибок во время выполнения.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 122,
            "questionEn": "Can you explain how elements are stored in memory for both regular arrays and ArrayLists in Java?",
            "answerEn": "In Java, regular arrays store elements in contiguous memory locations, allowing fast index-based access using the base address and element size. ArrayList, a dynamic array implementation, also keeps elements in contiguous memory for efficient access. However, when an ArrayList exceeds its capacity, it creates a larger underlying array and copies the existing elements into it. This resizing enables ArrayList to grow dynamically while maintaining contiguous storage. Thus, both structures use sequential memory, but ArrayList adds flexibility at the cost of occasional reallocation.",
            "questionRu": "Как элементы хранятся в памяти для обычных массивов и ArrayList в Java?",
            "answerRu": "В Java обычные массивы хранят элементы в непрерывных участках памяти, что позволяет быстро обращаться к ним по индексу, используя базовый адрес и размер элемента. ArrayList, реализующий динамический массив, также хранит элементы в непрерывной памяти для эффективного доступа. Однако при превышении емкости ArrayList создает новый, больший массив и копирует в него существующие элементы. Это изменение размера позволяет ArrayList динамически расти, сохраняя непрерывное хранение. Таким образом, оба типа используют последовательную память, но ArrayList добавляет гибкость за счет периодического перераспределения.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 123,
            "questionEn": "Explain the method to convert ArrayList to Array and Array to ArrayList.",
            "answerEn": "In Java, an array can be converted to an ArrayList using the Arrays.asList() method, which accepts the array and returns a List. This List can then be passed to the ArrayList constructor for a fully functional ArrayList. Conversely, an ArrayList can be converted to an array using the toArray() method, which returns an Object array by default. To specify a type, toArray(new Type[0]) can be used, ensuring a correctly typed array. These methods provide efficient and straightforward conversions between the two structures.",
            "questionRu": "Объясни метод преобразования ArrayList в массив и массива в ArrayList.",
            "answerRu": "В Java массив можно преобразовать в ArrayList с помощью метода Arrays.asList(), который принимает массив и возвращает List. Этот List затем можно передать в конструктор ArrayList для создания полноценного ArrayList. Обратно, ArrayList преобразуется в массив методом toArray(), который по умолчанию возвращает массив типа Object. Для указания типа можно использовать toArray(new Type[0]), что гарантирует массив нужного типа. Эти методы обеспечивают эффективное и простое преобразование между структурами.",
            "category": "Collections",
            "level": "Junior"
        },
        {
            "id": 124,
            "questionEn": "How does the size of ArrayList grow dynamically? And also state how it is implemented internally.",
            "answerEn": "ArrayList in Java grows dynamically by resizing its underlying array when it reaches capacity. Initially, it starts with a default capacity, typically 10 elements, depending on the Java version. When this capacity is exceeded, ArrayList creates a new array with a larger size—usually 1.5 times the previous capacity. The existing elements are then copied from the old array to the new one, and the reference is updated internally. This resizing process ensures ArrayList can accommodate additional elements efficiently.",
            "questionRu": "Как размер ArrayList увеличивается динамически? Как это реализовано внутри?",
            "answerRu": "ArrayList в Java увеличивается динамически путем изменения размера внутреннего массива при достижении его предела. Изначально он имеет стандартную емкость, обычно 10 элементов, в зависимости от версии Java. Когда эта емкость превышена, ArrayList создает новый массив большего размера — как правило, в 1,5 раза больше предыдущего. Существующие элементы копируются из старого массива в новый, а ссылка обновляется внутри. Этот процесс изменения размера позволяет ArrayList эффективно вмещать дополнительные элементы.",
            "category": "Collections",
            "level": "Junior"
        },
        {
            "id": 125,
            "questionEn": "What is a Vector in Java?",
            "answerEn": "A Vector in Java is a dynamic array-based data structure that can store multiple elements. Defined in the java.util package, it automatically adjusts its size as elements are added or removed. Unlike ArrayList, Vector is synchronized, ensuring thread safety by allowing only one thread to access it at a time. However, this synchronization comes at the cost of performance, making it less efficient for single-threaded applications. Vector is considered legacy, as it predates the modern Collections Framework.",
            "questionRu": "Что такое Vector в Java?",
            "answerRu": "Vector в Java — это структура данных на основе динамического массива, способная хранить множество элементов. Определенный в пакете java.util, он автоматически изменяет размер при добавлении или удалении элементов. В отличие от ArrayList, Vector синхронизирован, что обеспечивает безопасность потоков, позволяя только одному потоку работать с ним одновременно. Однако эта синхронизация снижает производительность, делая его менее эффективным для однопоточных приложений. Vector считается устаревшим, так как появился до современного Collections Framework.",
            "category": "Collections",
            "level": "Junior"
        },
        {
            "id": 126,
            "questionEn": "How to make Java ArrayList Read-Only?",
            "answerEn": "In Java, an ArrayList can be made read-only using the Collections.unmodifiableList() method. This method wraps the original ArrayList, returning a view that prevents modifications like adding or removing elements. Any attempt to alter the resulting List throws an UnsupportedOperationException at runtime. The original ArrayList remains mutable, but the read-only view enforces immutability for its users. This approach is useful for protecting data in scenarios requiring unchangeable collections.",
            "questionRu": "Как сделать ArrayList в Java только для чтения?",
            "answerRu": "В Java ArrayList можно сделать доступным только для чтения с помощью метода Collections.unmodifiableList(). Этот метод оборачивает исходный ArrayList, возвращая представление, которое запрещает изменения, такие как добавление или удаление элементов. Любая попытка изменить полученный List вызывает исключение UnsupportedOperationException во время выполнения. Исходный ArrayList остается изменяемым, но представление только для чтения обеспечивает неизменяемость для его пользователей. Этот подход полезен для защиты данных в ситуациях, требующих неизменяемых коллекций.",
            "category": "Collections",
            "level": "Junior"
        },
        {
            "id": 127,
            "questionEn": "What is a priority queue in Java?",
            "answerEn": "A PriorityQueue in Java is an abstract data type that extends the queue concept with priority-based ordering. Elements are stored and retrieved based on their priority, determined by their natural ordering or a custom comparator. Internally, it is implemented using a priority heap, typically a min-heap, ensuring the highest-priority element is always at the front. Methods like add() insert elements, while peek() and poll() access or remove the top-priority element. This structure is ideal for scenarios requiring ordered processing, such as task scheduling.",
            "questionRu": "Что такое приоритетная очередь в Java?",
            "answerRu": "PriorityQueue в Java — это абстрактный тип данных, расширяющий концепцию очереди с учетом приоритетного порядка. Элементы хранятся и извлекаются в зависимости от их приоритета, определяемого естественным порядком или пользовательским компаратором. Внутри он реализован на основе приоритетной кучи, обычно минимальной, что гарантирует нахождение элемента с наивысшим приоритетом в начале. Методы вроде add() добавляют элементы, а peek() и poll() позволяют получить или удалить элемент с наивысшим приоритетом. Эта структура идеальна для задач, требующих упорядоченной обработки, например, планирования задач.",
            "category": "Collections",
            "level": "Junior"
        },
        {
            "id": 128,
            "questionEn": "Explain the LinkedList class.",
            "answerEn": "The LinkedList class in Java is a collection that uses a doubly linked list to store elements. It implements the List and Deque interfaces, inheriting from AbstractList, enabling it to function as a list, queue, or stack. Unlike ArrayList, LinkedList is non-synchronized, making it unsuitable for thread-safe operations without external synchronization. It maintains insertion order and excels at frequent insertions or deletions due to its node-based structure. This flexibility makes it ideal for applications requiring dynamic data manipulation.",
            "questionRu": "Объясни класс LinkedList.",
            "answerRu": "Класс LinkedList в Java — это коллекция, использующая двусвязный список для хранения элементов. Он реализует интерфейсы List и Deque, наследуясь от AbstractList, что позволяет использовать его как список, очередь или стек. В отличие от ArrayList, LinkedList не синхронизирован, что делает его неподходящим для потокобезопасных операций без внешней синхронизации. Он сохраняет порядок вставки и эффективен при частых вставках или удалениях благодаря своей узловой структуре. Эта гибкость делает его идеальным для приложений, требующих динамической обработки данных.",
            "category": "Collections",
            "level": "Junior"
        },
        {
            "id": 129,
            "questionEn": "What is the Stack class in Java and what are the various methods provided by it?",
            "answerEn": "The Stack class in Java is a LIFO (Last In, First Out) data structure that extends the Vector class. It provides specialized methods for stack operations, implemented through its dynamic array-based inheritance. Key methods include push() to add an element to the top, pop() to remove and return the top element, and peek() to view the top element without removing it. Additionally, empty() checks if the stack is empty, and search() returns the position of an element from the top or -1 if not found. Though functional, Stack is considered legacy, with Deque preferred in modern Java.",
            "questionRu": "Что такое класс Stack в Java и какие методы он предоставляет?",
            "answerRu": "Класс Stack в Java — это структура данных LIFO (последним пришел, первым ушел), расширяющая класс Vector. Он предоставляет специализированные методы для операций со стеком, реализованные через унаследованный динамический массив. Основные методы включают push() для добавления элемента на вершину, pop() для удаления и возврата верхнего элемента и peek() для просмотра верхнего элемента без удаления. Также empty() проверяет, пуст ли стек, а search() возвращает позицию элемента от вершины или -1, если его нет. Хотя Stack функционален, он считается устаревшим, и в современном Java предпочтителен Deque.",
            "category": "Collections",
            "level": "Junior"
        },
        {
            "id": 130,
            "questionEn": "What is Set in the Java Collections framework and list down its various implementations?",
            "answerEn": "A Set in the Java Collections Framework is an interface representing a collection that prohibits duplicate elements. It does not guarantee any specific order unless implemented otherwise. HashSet, one implementation, uses a hash table for fast lookups and insertions without maintaining order. LinkedHashSet extends HashSet, preserving the insertion order of elements. TreeSet, another implementation, stores elements in a sorted order based on natural ordering or a custom comparator.",
            "questionRu": "Что такое Set в Java Collections Framework и какие у него реализации?",
            "answerRu": "Set в Java Collections Framework — это интерфейс, представляющий коллекцию, которая запрещает дубликаты элементов. Он не гарантирует определенного порядка, если не указано иное в реализации. HashSet, одна из реализаций, использует хэш-таблицу для быстрых поисков и вставок без сохранения порядка. LinkedHashSet расширяет HashSet, сохраняя порядок вставки элементов. TreeSet, другая реализация, хранит элементы в отсортированном порядке, основанном на естественном порядке или пользовательском компараторе.",
            "category": "Collections",
            "level": "Junior"
        },
        {
            "id": 131,
            "questionEn": "What is the HashSet class in Java and how does it store elements?",
            "answerEn": "The HashSet class in Java implements the Set interface within the Collections Framework, storing only unique elements. It uses a hash table internally, where each element is mapped to an index via a hash function. This function calculates the storage location based on the element’s hash code, enabling quick access. Assuming proper distribution by the hash function, HashSet offers constant-time performance for operations like add, remove, and contains. Collisions are handled using linked lists or trees at each index, ensuring efficient element management.",
            "questionRu": "Что такое класс HashSet в Java и как он хранит элементы?",
            "answerRu": "Класс HashSet в Java реализует интерфейс Set в рамках Collections Framework, храня только уникальные элементы. Внутри он использует хэш-таблицу, где каждый элемент отображается на индекс с помощью хэш-функции. Эта функция вычисляет место хранения на основе хэш-кода элемента, обеспечивая быстрый доступ. При условии хорошего распределения хэш-функцией HashSet обеспечивает постоянное время выполнения операций, таких как add, remove и contains. Коллизии обрабатываются с помощью связанных списков или деревьев на каждом индексе, гарантируя эффективное управление элементами.",
            "category": "Collections",
            "level": "Junior"
        },
        {
            "id": 132,
            "questionEn": "What is LinkedHashSet in Java Collections Framework?",
            "answerEn": "LinkedHashSet in the Java Collections Framework is an implementation of the Set interface that extends HashSet. It maintains a doubly-linked list across all elements to preserve insertion order. Unlike HashSet, which provides no ordering, LinkedHashSet ensures elements are iterated in the sequence they were added. It uses a hash table for storage, offering near-constant-time performance for basic operations like add and remove. This makes it suitable for applications requiring predictable iteration order with uniqueness.",
            "questionRu": "Что такое LinkedHashSet в Java Collections Framework?",
            "answerRu": "LinkedHashSet в Java Collections Framework — это реализация интерфейса Set, расширяющая HashSet. Он поддерживает двусвязный список для всех элементов, чтобы сохранить порядок вставки. В отличие от HashSet, не обеспечивающего порядка, LinkedHashSet гарантирует итерацию элементов в порядке их добавления. Для хранения используется хэш-таблица, что обеспечивает почти постоянное время выполнения операций, таких как add и remove. Это делает его подходящим для приложений, требующих предсказуемого порядка итерации с уникальностью.",
            "category": "Collections",
            "level": "Junior"
        },
        {
            "id": 133,
            "questionEn": "What is a Map interface in Java?",
            "answerEn": "The Map interface in Java, part of the java.util package, defines a collection for storing key-value pairs. Each key in a Map is unique, ensuring no duplicate keys exist. It provides methods like containsKey() and containsValue() to check for specific keys or values efficiently. Unlike other collections, Map does not extend the Collection interface but is integral to the Collections Framework. Common implementations include HashMap, LinkedHashMap, TreeMap, and SortedMap, each offering distinct behaviors.",
            "questionRu": "Что такое интерфейс Map в Java?",
            "answerRu": "Интерфейс Map в Java, входящий в пакет java.util, определяет коллекцию для хранения пар ключ-значение. Каждый ключ в Map уникален, что исключает дублирование ключей. Он предоставляет методы, такие как containsKey() и containsValue(), для эффективной проверки наличия ключей или значений. В отличие от других коллекций, Map не наследует интерфейс Collection, но является частью Collections Framework. Распространенные реализации включают HashMap, LinkedHashMap, TreeMap и SortedMap, каждая с уникальными характеристиками.",
            "category": "Collections",
            "level": "Junior"
        },
        {
            "id": 134,
            "questionEn": "Explain Treemap in Java.",
            "answerEn": "TreeMap in Java is a NavigableMap implementation that stores key-value pairs, maintaining them in sorted order based on keys. It is implemented using a red-black tree, ensuring efficient operations with a time complexity of O(log n). TreeMap requires unique keys, prohibits a null key, but allows multiple null values. It is not synchronized, making it unsuitable for thread-safe operations without external synchronization. The keys are automatically sorted in ascending order, which makes TreeMap ideal for applications requiring ordered data.",
            "questionRu": "Объясни TreeMap в Java.",
            "answerRu": "TreeMap в Java — это реализация NavigableMap, которая хранит пары ключ-значение, поддерживая их в отсортированном порядке по ключам. Она реализована с использованием красно-черного дерева, что обеспечивает эффективные операции со сложностью O(log n). TreeMap требует уникальных ключей, не допускает null в качестве ключа, но разрешает несколько null-значений. Он не синхронизирован, что делает его неподходящим для потокобезопасных операций без внешней синхронизации. Ключи автоматически сортируются по возрастанию, что делает TreeMap идеальным для приложений, требующих упорядоченных данных.",
            "category": "Collections",
            "level": "Junior"
        },
        {
            "id": 135,
            "questionEn": "What is EnumSet?",
            "answerEn": "EnumSet in Java is a specialized implementation of the Set interface designed exclusively for enumeration types. It ensures all elements come from a single enum type, providing type safety and efficiency. EnumSet is non-synchronized and faster than HashSet due to its optimized internal representation. It prohibits null elements, throwing a NullPointerException if attempted, and uses a fail-safe iterator to prevent concurrent modification issues. This makes EnumSet ideal for managing collections of enum values in a performant way.",
            "questionRu": "Что такое EnumSet?",
            "answerRu": "EnumSet в Java — это специализированная реализация интерфейса Set, предназначенная исключительно для типов перечислений. Он гарантирует, что все элементы принадлежат одному типу enum, обеспечивая безопасность типов и эффективность. EnumSet не синхронизирован и работает быстрее, чем HashSet, благодаря оптимизированной внутренней структуре. Он запрещает null-элементы, выбрасывая NullPointerException при попытке их добавить, и использует отказоустойчивый итератор для предотвращения проблем с конкурентными изменениями. Это делает EnumSet идеальным для управления наборами значений enum с высокой производительностью.",
            "category": "Collections",
            "level": "Junior"
        },
        {
            "id": 136,
            "questionEn": "What is BlockingQueue?",
            "answerEn": "A BlockingQueue in Java is a Queue implementation that supports operations waiting for the queue to become non-empty when retrieving or removing elements. It also waits for available space when adding elements, making it ideal for producer-consumer scenarios. This behavior ensures thread safety by blocking threads until the queue is accessible. BlockingQueue is widely used in concurrent programming to coordinate tasks efficiently. It extends the Queue interface with blocking capabilities for managing shared resources.",
            "questionRu": "Что такое BlockingQueue?",
            "answerRu": "BlockingQueue в Java — это реализация Queue, которая поддерживает операции ожидания, когда очередь становится непустой при извлечении или удалении элементов. Она также ожидает доступного места при добавлении элементов, что делает ее идеальной для сценариев производитель-потребитель. Такое поведение обеспечивает потокобезопасность, блокируя потоки до тех пор, пока очередь не станет доступной. BlockingQueue широко используется в конкурентном программировании для эффективной координации задач. Он расширяет интерфейс Queue, добавляя блокирующие возможности для управления общими ресурсами.",
            "category": "Collections",
            "level": "Junior"
        },
        {
            "id": 137,
            "questionEn": "What is the ConcurrentHashMap in Java and do you implement it?",
            "answerEn": "ConcurrentHashMap in Java is a thread-safe implementation of the Map interface, designed for concurrent access in multi-threaded environments. Unlike Hashtable, it uses segment-level locking or lock-free mechanisms (since Java 8) to allow multiple threads to read and write concurrently without blocking. It ensures high performance by minimizing contention, making it ideal for scalable applications. To use it, you can instantiate it directly, such as ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();, and perform operations like put() and get(). It does not allow null keys or values, throwing a NullPointerException if attempted.",
            "questionRu": "Что такое ConcurrentHashMap в Java и как его реализовать?",
            "answerRu": "ConcurrentHashMap в Java — это потокобезопасная реализация интерфейса Map, предназначенная для конкурентного доступа в многопоточных средах. В отличие от Hashtable, он использует блокировки на уровне сегментов или бесконфликтные механизмы (с Java 8), позволяя нескольким потокам читать и писать одновременно без блокировки. Это обеспечивает высокую производительность за счет минимизации конкуренции, что делает его идеальным для масштабируемых приложений. Для использования его можно создать напрямую, например, ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();, и выполнять операции, такие как put() и get(). Он не допускает null-ключей или значений, выбрасывая NullPointerException при попытке их добавить.",
            "category": "Collections",
            "level": "Junior"
        },
        {
            "id": 138,
            "questionEn": "Can you use any class as a Map key?",
            "answerEn": "Yes, any class can be used as a Map key in Java if it adheres to specific rules. The class must override the equals() method to define object equality and the hashCode() method to ensure consistent hash values. These overrides must be consistent, meaning equal objects must have the same hash code for proper Map functionality. Additionally, null keys are not allowed in implementations like ConcurrentHashMap, which throws a NullPointerException. This ensures reliable key-based operations in Map collections.",
            "questionRu": "Можно ли использовать любой класс как ключ Map?",
            "answerRu": "Да, любой класс может использоваться как ключ Map в Java, если он соответствует определенным правилам. Класс должен переопределять метод equals() для определения равенства объектов и метод hashCode() для обеспечения согласованных значений хэша. Эти переопределения должны быть согласованными, то есть равные объекты должны иметь одинаковый хэш-код для корректной работы Map. Кроме того, ключи null запрещены в реализациях, таких как ConcurrentHashMap, который выбрасывает NullPointerException. Это гарантирует надежные операции на основе ключей в коллекциях Map.",
            "category": "Collections",
            "level": "Junior"
        },
        {
            "id": 139,
            "questionEn": "What is an Iterator?",
            "answerEn": "An Iterator in Java is an interface that enables traversal over elements in any Collection, such as lists or sets. It replaces the older Enumeration in the Java Collections Framework, offering a more modern approach. You can obtain an Iterator instance from a Collection using the iterator() method. It provides methods to iterate sequentially and allows removing elements during iteration without causing concurrent modification issues. This makes Iterator essential for safely navigating and modifying collections.",
            "questionRu": "Что такое Iterator?",
            "answerRu": "Iterator в Java — это интерфейс, который позволяет обходить элементы любой коллекции, например, списков или множеств. Он заменяет устаревший Enumeration в Java Collections Framework, предоставляя более современный подход. Экземпляр Iterator можно получить из коллекции с помощью метода iterator(). Он предоставляет методы для последовательного обхода и позволяет удалять элементы во время итерации без проблем с конкурентными изменениями. Это делает Iterator незаменимым для безопасного обхода и модификации коллекций.",
            "category": "Collections",
            "level": "Junior"
        },
        {
            "id": 140,
            "questionEn": "What is an enumeration?",
            "answerEn": "An enumeration in Java is a user-defined data type that allows assigning names to integral constants. Its primary purpose is to improve code readability and maintainability by replacing numeric values with meaningful identifiers. Enums are declared using the enum keyword and are particularly useful for representing a fixed set of related constants. They ensure type safety by restricting variables to predefined values. This makes enums a powerful tool for managing state or options in a program.",
            "questionRu": "Что такое перечисление?",
            "answerRu": "Перечисление в Java — это пользовательский тип данных, который позволяет присваивать имена целочисленным константам. Его основная цель — улучшить читаемость и поддерживаемость кода, заменяя числовые значения на понятные идентификаторы. Перечисления объявляются с помощью ключевого слова enum и особенно полезны для представления фиксированного набора связанных констант. Они обеспечивают безопасность типов, ограничивая переменные предопределенными значениями. Это делает перечисления мощным инструментом для управления состояниями или вариантами в программе.",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 141,
            "questionEn": "What is the difference between Collection and Collections?",
            "answerEn": "Collection in Java is an interface that defines the standard functionality for data structures like lists, sets, and queues. In contrast, Collections is a utility class that provides static methods for operating on or manipulating collections. Collection offers methods for basic operations, such as adding or removing elements in a data structure. Collections, however, includes methods for advanced operations like sorting, synchronizing, or searching within collection elements. This distinction makes Collection the foundation for data storage, while Collections enhances its functionality with helper methods.",
            "questionRu": "Чем отличается Collection от Collections?",
            "answerRu": "Collection в Java — это интерфейс, который определяет стандартную функциональность для структур данных, таких как списки, множества и очереди. В отличие от него, Collections — это утилитный класс, предоставляющий статические методы для работы с коллекциями или их манипуляции. Collection предлагает методы для базовых операций, таких как добавление или удаление элементов в структуре данных. Collections же включает методы для продвинутых операций, таких как сортировка, синхронизация или поиск внутри элементов коллекции. Это различие делает Collection основой для хранения данных, а Collections расширяет его функциональность с помощью вспомогательных методов.",
            "category": "Collections",
            "level": "Junior"
        },
        {
            "id": 142,
            "questionEn": "Differentiate between Array and ArrayList in Java.",
            "answerEn": "An Array in Java can be single-dimensional or multidimensional with a fixed size, determined at creation, while ArrayList is single-dimensional with a dynamic size that can grow or shrink. Arrays use the length property and for/foreach loops for iteration, whereas ArrayList uses the size() method and an Iterator for traversal. Arrays can store primitive data types directly, but ArrayList requires autoboxing/unboxing for primitives, making it type-safe with generics. Arrays offer faster access due to their fixed nature, while ArrayList is slower due to its dynamic resizing. Elements are assigned to Arrays using the assignment operator, while ArrayList uses the add() method.",
            "questionRu": "Чем отличается массив от ArrayList в Java?",
            "answerRu": "Массив в Java может быть одномерным или многомерным с фиксированным размером, заданным при создании, тогда как ArrayList — только одномерный с динамическим размером, который может увеличиваться или уменьшаться. Массивы используют свойство length и циклы for/foreach для итерации, в то время как ArrayList использует метод size() и итератор для обхода. Массивы могут напрямую хранить примитивные типы данных, тогда как ArrayList требует автоупаковки/распаковки для примитивов, обеспечивая типобезопасность с помощью generics. Массивы обеспечивают более быстрый доступ благодаря фиксированному размеру, в то время как ArrayList медленнее из-за динамического изменения размера. Элементы присваиваются массивам с помощью оператора присваивания, а ArrayList использует метод add().",
            "category": "Java Core",
            "level": "Junior"
        },
        {
            "id": 143,
            "questionEn": "What is the difference between Array and Collection in Java?",
            "answerEn": "An Array in Java has a fixed size with elements stored in contiguous memory locations, while Collections have dynamic sizes with non-contiguous storage. Arrays can store both primitive data types and objects, whereas Collections only support objects. Resizing an Array requires manual manipulation, but Collections handle resizing automatically. Arrays provide basic manipulation methods, while Collections offer advanced methods for iteration and management. Arrays have been available since the beginning of Java, while Collections were introduced in Java 1.2.",
            "questionRu": "Чем отличается массив от коллекции в Java?",
            "answerRu": "Массив в Java имеет фиксированный размер с элементами, хранящимися в непрерывных областях памяти, тогда как коллекции обладают динамическим размером с неконтингуальным хранением. Массивы могут содержать как примитивные типы данных, так и объекты, в то время как коллекции поддерживают только объекты. Изменение размера массива требует ручной обработки, тогда как коллекции управляют этим автоматически. Массивы предоставляют базовые методы манипуляции, а коллекции — продвинутые методы для итерации и управления. Массивы доступны с самого начала Java, тогда как коллекции были введены в Java 1.2.",
            "category": "Collections",
            "level": "Junior"
        },
        {
            "id": 144,
            "questionEn": "Difference between ArrayList and LinkedList.",
            "answerEn": "ArrayList in Java is implemented as a resizable array with elements stored in contiguous memory locations, while LinkedList is implemented as a doubly-linked list with non-contiguous storage. ArrayList provides faster random access due to its array structure, whereas LinkedList excels in insertion and deletion operations due to its node-based design. ArrayList may use more memory to maintain its array capacity, while LinkedList consumes less memory per element but requires space for references. The search operation is faster in ArrayList with index-based access, but slower in LinkedList due to sequential traversal. These differences make each suitable for specific use cases, such as frequent access versus frequent",
            "questionRu": "Чем отличается ArrayList от LinkedList?",
            "answerRu": "ArrayList в Java реализован как расширяемый массив с элементами, хранящимися в непрерывных областях памяти, в то время как LinkedList реализован как двунаправленный связный список с неконтингуальным хранением. ArrayList обеспечивает более быстрый произвольный доступ благодаря своей массивной структуре, тогда как LinkedList превосходит в операциях вставки и удаления благодаря своей основе на узлах. ArrayList может использовать больше памяти для поддержания емкости массива, тогда как LinkedList требует меньше памяти на элемент, но занимает место для ссылок. Операция поиска быстрее в ArrayList за счет доступа по индексу, но медленнее в LinkedList из-за последовательного обхода. Эти различия делают каждый из них подходящим для конкретных случаев использования, таких как частый доступ или частые модификации.",
            "category": "Collections",
            "level": "Junior"
        },
        {
            "id": 145,
            "questionEn": "Differentiate between ArrayList and Vector in Java.",
            "answerEn": "ArrayList in Java is implemented as a non-synchronized resizable array, while Vector is a synchronized resizable array designed for thread safety. ArrayList offers faster performance in single-threaded environments due to the absence of synchronization overhead, whereas Vector is slower in such cases due to its synchronized methods. ArrayList was introduced in Java 1.2, while Vector, a legacy class, debuted in JDK 1.0. ArrayList is recommended for single-threaded applications, while Vector suits multi-threaded environments requiring thread safety. This distinction reflects their design focus on performance versus concurrency.",
            "questionRu": "Чем отличается ArrayList от Vector в Java?",
            "answerRu": "ArrayList в Java реализован как несинхронизированный расширяемый массив, тогда как Vector — это синхронизированный расширяемый массив, разработанный для потокобезопасности. ArrayList обеспечивает более высокую производительность в однопоточных средах благодаря отсутствию накладных расходов на синхронизацию, в то время как Vector медленнее из-за своих синхронизированных методов. ArrayList был введен в Java 1.2, тогда как Vector, являясь устаревшим классом, появился в JDK 1.0. ArrayList рекомендуется для однопоточных приложений, а Vector подходит для многопоточных сред, требующих потокобезопасности. Это различие отражает их ориентацию на производительность против конкурентности.",
            "category": "Collections",
            "level": "Junior"
        },
        {
            "id": 146,
            "questionEn": "What is the difference between Iterator and ListIterator?",
            "answerEn": "Iterator in Java allows traversal of elements in a Collection only in the forward direction, while ListIterator supports both forward and backward traversal. Iterator can be used with Map, List, and Set, whereas ListIterator is exclusive to List implementations. Iterator does not provide access to element indexes, but ListIterator offers methods like nextIndex() and previousIndex() for this purpose. Iterator cannot modify or replace elements, while ListIterator can do so using its set() method. Additionally, ListIterator allows adding elements during iteration, unlike Iterator, which throws a ConcurrentModificationException if the structure is altered.",
            "questionRu": "Чем отличается Iterator от ListIterator?",
            "answerRu": "Iterator в Java позволяет обходить элементы коллекции только в прямом направлении, тогда как ListIterator поддерживает обход как вперед, так и назад. Iterator можно использовать с Map, List и Set, в то время как ListIterator применим только к реализациям List. Iterator не предоставляет доступ к индексам элементов, но ListIterator имеет методы, такие как nextIndex() и previousIndex(), для этой цели. Iterator не может изменять или заменять элементы, тогда как ListIterator может это делать с помощью метода set(). Кроме того, ListIterator позволяет добавлять элементы во время итерации, в отличие от Iterator, который выбрасывает ConcurrentModificationException при изменении структуры.",
            "category": "Collections",
            "level": "Junior"
        },
        {
            "id": 147,
            "questionEn": "Differentiate between HashMap and HashTable.",
            "answerEn": "HashMap in Java is not synchronized, making it suitable for single-threaded environments, while HashTable is synchronized, designed for thread-safe operations in multi-threaded scenarios. HashMap allows one null key and multiple null values, whereas HashTable does not permit any null keys or values, throwing a NullPointerException. HashMap uses an Iterator for traversal, while HashTable supports both Iterator and the older Enumeration. HashMap offers faster performance due to the absence of synchronization overhead, while HashTable is slower because of its thread-safety mechanisms. These differences make HashMap preferable for non-concurrent applications and HashTable for legacy or thread-safe needs.",
            "questionRu": "Чем отличается HashMap от HashTable?",
            "answerRu": "HashMap в Java не синхронизирован, что делает его подходящим для однопоточных сред, тогда как HashTable синхронизирован и предназначен для потокобезопасных операций в многопоточных сценариях. HashMap допускает один null-ключ и несколько null-значений, тогда как HashTable не разрешает ни null-ключи, ни null-значения, выбрасывая NullPointerException. HashMap использует Iterator для обхода, в то время как HashTable поддерживает как Iterator, так и устаревший Enumeration. HashMap обеспечивает более высокую производительность благодаря отсутствию накладных расходов на синхронизацию, тогда как HashTable медленнее из-за своих механизмов потокобезопасности. Эти различия делают HashMap предпочтительным для некритических к конкурентности приложений, а HashTable — для устаревших или потокобезопасных нужд.",
            "category": "Collections",
            "level": "Junior"
        },
        {
            "id": 148,
            "questionEn": "What is the difference between Iterator and Enumeration?",
            "answerEn": "Iterator in Java can traverse both legacy and modern collections, while Enumeration is limited to legacy collections like Vector and Hashtable. Iterator is fail-fast, throwing a ConcurrentModificationException if the collection is modified during traversal, whereas Enumeration is not fail-fast and may produce unpredictable results. Iterator supports removing elements during traversal, but Enumeration only allows traversal without modification. Enumeration is generally faster than Iterator because it lacks additional checks for modification. These differences make Iterator more versatile and safer for modern applications, while Enumeration suits older, simpler use cases.",
            "questionRu": "Чем отличается Iterator от Enumeration?",
            "answerRu": "Iterator в Java может обходить как устаревшие, так и современные коллекции, тогда как Enumeration ограничен устаревшими коллекциями, такими как Vector и Hashtable. Iterator является отказоустойчивым, выбрасывая ConcurrentModificationException при изменении коллекции во время обхода, в то время как Enumeration не отказоустойчив и может давать непредсказуемые результаты. Iterator позволяет удалять элементы во время обхода, но Enumeration поддерживает только обход без модификации. Enumeration обычно быстрее Iterator, поскольку не выполняет дополнительных проверок на изменения. Эти различия делают Iterator более универсальным и безопасным для современных приложений, тогда как Enumeration подходит для старых и простых случаев использования.",
            "category": "Collections",
            "level": "Junior"
        },
        {
            "id": 149,
            "questionEn": "What is the difference between Comparable and Comparator?",
            "answerEn": "Comparable and Comparator are interfaces in Java used for sorting objects, but they differ in their implementation and flexibility. Comparable, found in the java.lang package, uses the compareTo() method to define a natural sorting order within the class itself, affecting the original class. In contrast, Comparator, located in java.util, uses the compare() method and allows sorting logic to be defined in a separate class, leaving the original class unchanged. Comparable supports a single, fixed sorting sequence, while Comparator enables multiple, customizable sorting sequences. This makes Comparator more flexible for sorting objects based on different attributes without modifying their class.",
            "questionRu": "Чем отличается Comparable от Comparator?",
            "answerRu": "Comparable и Comparator — это интерфейсы в Java, используемые для сортировки объектов, но они различаются по реализации и гибкости. Comparable, находящийся в пакете java.lang, использует метод compareTo() для определения естественного порядка сортировки внутри самого класса, влияя на оригинальный класс. В отличие от этого, Comparator, расположенный в java.util, использует метод compare() и позволяет определить логику сортировки в отдельном классе, не изменяя исходный класс. Comparable поддерживает единую фиксированную последовательность сортировки, тогда как Comparator позволяет создавать несколько настраиваемых последовательностей сортировки. Это делает Comparator более гибким для сортировки объектов по различным атрибутам без изменения их класса.",
            "category": "Collections",
            "level": "Junior"
        },
        {
            "id": 150,
            "questionEn": "What is the difference between Set and Map?",
            "answerEn": "Set and Map are interfaces in Java’s java.util package, but they serve different purposes for data storage. Set extends the Collection interface and represents a group of unique elements, not allowing duplicates. Map does not extend Collection and instead stores key-value pairs, where keys must be unique, but values can be duplicated. Set allows only one null element in implementations like HashSet, while Map permits one null key and multiple null values in implementations like HashMap. These differences make Set ideal for storing distinct elements and Map for associative mappings.",
            "questionRu": "Чем отличается Set от Map?",
            "answerRu": "Set и Map — это интерфейсы в пакете java.util в Java, но они предназначены для разных целей хранения данных. Set расширяет интерфейс Collection и представляет группу уникальных элементов, не допуская дубликатов. Map не расширяет Collection и хранит пары ключ-значение, где ключи должны быть уникальными, но значения могут дублироваться. Set позволяет хранить только один null-элемент в реализациях, таких как HashSet, тогда как Map допускает один null-ключ и несколько null-значений в реализациях, таких как HashMap. Эти различия делают Set идеальным для хранения уникальных элементов, а Map — для ассоциативных отображений.",
            "category": "Collections",
            "level": "Junior"
        },
        {
            "id": 151,
            "questionEn": "Explain the FailFast iterator and FailSafe iterator along with examples for each.",
            "answerEn": "A FailFast iterator, like the one used in HashMap, throws a ConcurrentModificationException if the underlying collection is modified during iteration. It detects structural changes, such as adding or removing elements, and fails immediately to prevent inconsistent states. In contrast, a FailSafe iterator, as seen in ConcurrentHashMap, operates on a snapshot of the collection, allowing modifications without throwing exceptions. For example, removing an entry from a HashMap while iterating causes an exception, but the same operation on a ConcurrentHashMap succeeds silently. This distinction makes FailFast suitable for single-threaded safety and FailSafe ideal for concurrent environments.",
            "questionRu": "Объясни FailFast и FailSafe итераторы с примерами.",
            "answerRu": "Итератор FailFast, например, в HashMap, выбрасывает ConcurrentModificationException, если коллекция изменяется во время итерации. Он обнаруживает структурные изменения, такие как добавление или удаление элементов, и немедленно завершается, предотвращая несогласованные состояния. Напротив, итератор FailSafe, как в ConcurrentHashMap, работает с моментальной копией коллекции, позволяя изменения без исключений. Например, удаление элемента из HashMap во время итерации вызывает исключение, но в ConcurrentHashMap операция проходит без ошибок. Это различие делает FailFast подходящим для однопоточной безопасности, а FailSafe — идеальным для параллельных сред.",
            "category": "Collections",
            "level": "Middle"
        },
        {
            "id": 152,
            "questionEn": "What is Exception Handling?",
            "answerEn": "Exception handling in Java is a mechanism to manage runtime errors that disrupt the normal flow of a program. An exception is an event, such as invalid input or a file not found, requiring special processing to prevent program termination. It uses constructs like try, catch, and throw to isolate and handle these issues gracefully. For example, attempting to open an unavailable file throws an IOException, which can be caught and managed. This approach ensures robustness and reliability in Java applications.",
            "questionRu": "Что такое обработка исключений?",
            "answerRu": "Обработка исключений в Java — это механизм управления ошибками времени выполнения, нарушающими нормальный ход программы. Исключение — это событие, например, неверный ввод или отсутствие файла, требующее особой обработки для предотвращения завершения программы. Для этого используются конструкции try, catch и throw, чтобы изолировать и обработать такие проблемы корректно. Например, попытка открыть недоступный файл вызывает IOException, которое можно поймать и обработать. Этот подход обеспечивает надёжность и устойчивость приложений на Java.",
            "category": "Exception Handling",
            "level": "Middle"
        },
        {
            "id": 153,
            "questionEn": "How many types of exceptions can occur in a Java program?",
            "answerEn": "In Java, exceptions are broadly classified into two types: built-in and user-defined. Built-in exceptions, provided by Java libraries, include checked exceptions, like IOException, caught at compile time, and unchecked exceptions, like NullPointerException, detected at runtime. User-defined exceptions are custom exceptions created by programmers to address specific scenarios not covered by built-in ones. For example, a programmer might define a CustomOrderException by extending Exception for a unique business rule violation. These types enable comprehensive error handling tailored to application needs.",
            "questionRu": "Сколько типов исключений может быть в Java-программе?",
            "answerRu": "В Java исключения делятся на два основных типа: встроенные и пользовательские. Встроенные исключения, предоставленные библиотеками Java, включают проверяемые исключения, такие как IOException, обнаруживаемые на этапе компиляции, и непроверяемые, такие как NullPointerException, возникающие во время выполнения. Пользовательские исключения — это кастомные исключения, создаваемые программистами для специфических ситуаций, не охваченных встроенными. Например, можно определить CustomOrderException, расширив Exception, для уникального нарушения бизнес-правила. Эти типы обеспечивают всестороннюю обработку ошибок, адаптированную под нужды приложения.",
            "category": "Exception Handling",
            "level": "Middle"
        },
        {
            "id": 154,
            "questionEn": "Difference between an Error and an Exception.",
            "answerEn": "In Java, an Error represents severe issues, like OutOfMemoryError, from which recovery is typically impossible, often due to environmental failures. An Exception, such as IOException or NullPointerException, indicates recoverable problems usually caused by the program itself. Errors are unchecked and can occur at compile time (e.g., syntax errors) or runtime, while exceptions occur only at runtime and include both checked and unchecked types. Errors are defined in java.lang.Error, signaling system-level faults, whereas exceptions, defined in java.lang.Exception, are manageable via try-catch blocks. This distinction helps developers prioritize handling exceptions over fatal errors.",
            "questionRu": "Чем отличается Error от Exception?",
            "answerRu": "В Java Error обозначает серьёзные проблемы, такие как OutOfMemoryError, от которых восстановление обычно невозможно, часто из-за сбоев окружения. Exception, например IOException или NullPointerException, указывает на восстанавливаемые ошибки, вызванные чаще самой программой. Ошибки (Error) — непроверяемые и могут возникать на этапе компиляции (например, синтаксические ошибки) или выполнения, тогда как исключения возникают только во время выполнения и бывают проверяемыми и непроверяемыми. Ошибки определены в java.lang.Error и сигнализируют о системных сбоях, а исключения, определённые в java.lang.Exception, обрабатываются через try-catch. Это различие помогает разработчикам фокусироваться на обработке исключений, а не фатальных ошибок.",
            "category": "Exception Handling",
            "level": "Middle"
        },
        {
            "id": 155,
            "questionEn": "Explain the hierarchy of Java Exception classes.",
            "answerEn": "In Java, the exception hierarchy begins with the Throwable class, which serves as the root for all errors and exceptions. The Exception branch, a direct subclass of Throwable, handles recoverable conditions in user programs, such as NullPointerException. Within Exception, subclasses like IOException (checked) and RuntimeException (unchecked) address specific runtime issues. The Error branch, also a subclass of Throwable, represents unrecoverable system-level issues in the Java Runtime Environment, exemplified by StackOverflowError. This hierarchy separates programmatic exceptions from critical JVM failures.",
            "questionRu": "Объясни иерархию классов исключений в Java.",
            "answerRu": "В Java иерархия исключений начинается с класса Throwable, который является корнем для всех ошибок и исключений. Ветвь Exception, прямой подкласс Throwable, обрабатывает восстанавливаемые условия в пользовательских программах, например, NullPointerException. Внутри Exception подклассы, такие как IOException (проверяемые) и RuntimeException (непроверяемые), решают конкретные проблемы времени выполнения. Ветвь Error, также подкласс Throwable, обозначает невосстанавливаемые системные сбои в среде выполнения Java, например, StackOverflowError. Эта иерархия разделяет программные исключения и критические сбои JVM.",
            "category": "Exception Handling",
            "level": "Middle"
        },
        {
            "id": 156,
            "questionEn": "Explain Runtime Exceptions.",
            "answerEn": "Runtime exceptions in Java are unchecked exceptions that occur during program execution, not at compile time. They inherit from RuntimeException and include errors like NullPointerException or ArithmeticException, caused by invalid operations such as dereferencing null or dividing by zero. Unlike checked exceptions, they don’t require mandatory handling via throws or try-catch, as the JVM doesn’t enforce their declaration. These exceptions often indicate programming mistakes, making them valuable for debugging and error correction. Handling them is optional but recommended to enhance application stability.",
            "questionRu": "Объясни исключения времени выполнения.",
            "answerRu": "Исключения времени выполнения в Java — это непроверяемые исключения, возникающие во время выполнения программы, а не на этапе компиляции. Они наследуются от RuntimeException и включают ошибки, такие как NullPointerException или ArithmeticException, вызванные некорректными операциями, например, обращением к null или делением на ноль. В отличие от проверяемых исключений, они не требуют обязательной обработки через throws или try-catch, так как JVM не настаивает на их объявлении. Эти исключения часто указывают на ошибки программирования, что делает их полезными для отладки и исправления. Их обработка необязательна, но рекомендуется для повышения стабильности приложения.",
            "category": "Exception Handling",
            "level": "Middle"
        },
        {
            "id": 157,
            "questionEn": "What is NullPointerException?",
            "answerEn": "A NullPointerException is an unchecked runtime exception in Java thrown when a program attempts to access or manipulate an object reference that is null. It occurs when no value has been assigned to a reference variable, signaling a programming error or uninitialized state. For example, calling a method like string.length() on a null string variable triggers this exception. It’s commonly encountered in data structures like linked lists, where a null reference might indicate the end of the list. Handling or avoiding it improves code robustness by ensuring references are properly initialized.",
            "questionRu": "Что такое NullPointerException?",
            "answerRu": "NullPointerException — это непроверяемое исключение времени выполнения в Java, возникающее при попытке доступа или работы с объектной ссылкой, равной null. Оно возникает, когда ссылочной переменной не присвоено значение, указывая на ошибку программирования или неинициализированное состояние. Например, вызов метода string.length() для строки со значением null вызывает это исключение. Оно часто встречается в структурах данных, таких как связные списки, где null может обозначать конец списка. Обработка или предотвращение этого исключения повышает надёжность кода за счёт корректной инициализации ссылок.",
            "category": "Exception Handling",
            "level": "Middle"
        },
        {
            "id": 158,
            "questionEn": "When is the ArrayStoreException thrown?",
            "answerEn": "An ArrayStoreException is a runtime exception thrown in Java when an attempt is made to store an object of an incompatible type in an array. It occurs due to type mismatch, as Java enforces type safety for array elements based on the array’s declared type. For example, assigning an Integer to a Double[] array triggers this exception because Integer isn’t a subtype of Double. This check happens at runtime, even though the array’s type is defined at compile time. It ensures arrays maintain their intended type consistency during execution.",
            "questionRu": "Когда выбрасывается ArrayStoreException?",
            "answerRu": "ArrayStoreException — это исключение времени выполнения в Java, возникающее при попытке сохранить объект несовместимого типа в массиве. Оно происходит из-за несоответствия типов, так как Java обеспечивает типобезопасность элементов массива на основе его объявленного типа. Например, попытка присвоить Integer массиву Double[] вызывает это исключение, поскольку Integer не является подтипом Double. Эта проверка выполняется во время выполнения, хотя тип массива определён на этапе компиляции. Это гарантирует сохранение согласованности типов массива во время работы программы.",
            "category": "Exception Handling",
            "level": "Middle"
        },
        {
            "id": 159,
            "questionEn": "What is the difference between Checked Exception and Unchecked Exception?",
            "answerEn": "Checked exceptions are exceptions that the Java compiler verifies at compile time, requiring explicit handling with a try-catch block or declaration via the throws keyword. Examples include IOException, which must be addressed before the code compiles successfully. Unchecked exceptions, derived from RuntimeException or Error, are not checked at compile time and occur only during execution, like NullPointerException. Checked exceptions typically represent external issues, while unchecked ones often stem from programming errors. This distinction enforces proactive error handling for predictable problems and flexibility for runtime issues.",
            "questionRu": "Чем отличается проверяемое исключение от непроверяемого?",
            "answerRu": "Проверяемые исключения — это исключения, которые компилятор Java проверяет на этапе компиляции, требуя явной обработки через try-catch или объявления с помощью throws. Примером служит IOException, которое нужно обработать для успешной компиляции кода. Непроверяемые исключения, происходящие от RuntimeException или Error, не проверяются на этапе компиляции и возникают только во время выполнения, например, NullPointerException. Проверяемые исключения обычно связаны с внешними проблемами, а непроверяемые — с ошибками программирования. Это различие обеспечивает проактивную обработку предсказуемых проблем и гибкость для ошибок времени выполнения.",
            "category": "Exception Handling",
            "level": "Middle"
        },
        {
            "id": 160,
            "questionEn": "What is the base class for Error and Exception?",
            "answerEn": "The base class for both Error and Exception in Java is java.lang.Throwable. Throwable serves as the root of the exception hierarchy, providing common methods like getMessage() and printStackTrace() for error handling. Error, a subclass of Throwable, represents unrecoverable system issues, such as OutOfMemoryError. Exception, another subclass, covers recoverable conditions, like IOException, that programs can handle. This unified parent class enables consistent management of all exceptional events in Java.",
            "questionRu": "Какой базовый класс для Error и Exception?",
            "answerRu": "Базовым классом для Error и Exception в Java является java.lang.Throwable. Throwable выступает корнем иерархии исключений, предоставляя общие методы, такие как getMessage() и printStackTrace(), для обработки ошибок. Error, подкласс Throwable, обозначает невосстанавливаемые системные сбои, например, OutOfMemoryError. Exception, другой подкласс, охватывает восстанавливаемые условия, такие как IOException, которые программы могут обработать. Этот общий родительский класс обеспечивает единообразное управление всеми исключительными событиями в Java.",
            "category": "Exception Handling",
            "level": "Middle"
        },
        {
            "id": 161,
            "questionEn": "Is it necessary that each try block must be followed by a catch block?",
            "answerEn": "In Java, it is not mandatory for a try block to be followed by a catch block. A try block can be paired with a finally block alone, which executes regardless of whether an exception occurs. This allows resource cleanup, like closing a file, without handling the exception explicitly. For example, try { file.open(); } finally { file.close(); } ensures cleanup even if an exception is thrown. However, if neither catch nor finally is present, the code won’t compile.",
            "questionRu": "Обязательно ли каждый try-блок должен сопровождаться catch-блоком?",
            "answerRu": "В Java не обязательно, чтобы за блоком try следовал блок catch. Блок try может использоваться только с блоком finally, который выполняется независимо от возникновения исключения. Это позволяет освобождать ресурсы, например закрывать файл, без явной обработки исключения. Например, try { file.open(); } finally { file.close(); } гарантирует очистку, даже если исключение возникло. Однако без catch или finally код не скомпилируется.",
            "category": "Exception Handling",
            "level": "Middle"
        },
        {
            "id": 162,
            "questionEn": "What is exception propagation?",
            "answerEn": "Exception propagation in Java is the mechanism by which an unhandled exception travels up the call stack from the method where it occurs. When an exception is thrown and not caught in the current method, it is passed to the calling method. This process continues upward through the stack until a try-catch block handles it or it reaches the top, causing program termination. For example, if a method divide() throws an ArithmeticException and doesn’t catch it, the exception propagates to the caller. It ensures errors are either resolved or escalated appropriately in the program flow.",
            "questionRu": "Что такое распространение исключений?",
            "answerRu": "Передача исключений в Java — это механизм, при котором необработанное исключение поднимается вверх по стеку вызовов от метода, где оно возникло. Если исключение выброшено и не поймано в текущем методе, оно передаётся вызывающему методу. Этот процесс продолжается вверх по стеку, пока блок try-catch не обработает его или оно не достигнет вершины, вызвав завершение программы. Например, если метод divide() выбрасывает ArithmeticException и не ловит его, исключение передаётся вызывающему методу. Это гарантирует, что ошибки либо разрешаются, либо корректно эскалируются в потоке программы.",
            "category": "Exception Handling",
            "level": "Middle"
        },
        {
            "id": 163,
            "questionEn": "What will happen if you put System.exit(0) in the try or catch block? Will finally block execute?",
            "answerEn": "When System.exit(0) is called within a try or catch block, it terminates the JVM immediately, preventing the finally block from executing. This method forces an abrupt shutdown with an exit status of 0, overriding the normal flow of exception handling. However, if a SecurityManager restricts System.exit(0) and throws a SecurityException, the finally block will execute as the JVM continues running. For example, try { System.exit(0); } finally { System.out.println(\"Finally\"); } typically skips the finally unless a security exception occurs. Thus, finally execution depends on whether System.exit() succeeds or is interrupted.",
            "questionRu": "Что произойдет, если поставить System.exit(0) в try или catch? Выполнится ли finally?",
            "answerRu": "Когда System.exit(0) вызывается в блоке try или catch, он немедленно завершает работу JVM, не позволяя блоку finally выполниться. Этот метод принудительно останавливает программу с кодом завершения 0, прерывая нормальный поток обработки исключений. Однако, если SecurityManager ограничивает System.exit(0) и выбрасывает SecurityException, блок finally выполняется, так как JVM продолжает работу. Например, в try { System.exit(0); } finally { System.out.println(\"Finally\"); } блок finally обычно пропускается, если не возникает исключение безопасности. Таким образом, выполнение finally зависит от успешности или прерывания System.exit().",
            "category": "Exception Handling",
            "level": "Middle"
        },
        {
            "id": 164,
            "questionEn": "What do you understand by Object Cloning and how do you achieve it in Java?",
            "answerEn": "Object cloning in Java is the process of creating an exact copy of an object, duplicating its state. To achieve this, a class must implement the Cloneable interface from java.lang and override the clone() method from the Object class. The overridden clone() typically calls super.clone() to perform a shallow copy, returning the new object. For example, class MyClass implements Cloneable { public Object clone() throws CloneNotSupportedException { return super.clone(); } } enables cloning. Without implementing Cloneable, invoking clone() throws a CloneNotSupportedException.",
            "questionRu": "Что вы понимаете под клонированием объектов и как это сделать в Java?",
            "answerRu": "Клонирование объектов в Java — это процесс создания точной копии объекта, дублирующей его состояние. Для этого класс должен реализовать интерфейс Cloneable из пакета java.lang и переопределить метод clone() из класса Object. Переопределённый clone() обычно вызывает super.clone() для выполнения поверхностного копирования, возвращая новый объект. Например, class MyClass implements Cloneable { public Object clone() throws CloneNotSupportedException { return super.clone(); } } позволяет клонировать. Без реализации Cloneable вызов clone() выбрасывает CloneNotSupportedException.",
            "category": "Object-Oriented Programming (OOP)",
            "level": "Middle"
        },
        {
            "id": 165,
            "questionEn": "How do exceptions affect the program if it doesn’t handle them?",
            "answerEn": "If exceptions are not handled in a Java program, they cause the program to terminate abruptly at the point of occurrence. The runtime system propagates the exception up the call stack until it’s caught or reaches the top, halting execution. Any code following the exception in the current method or subsequent calls is skipped, leaving tasks incomplete. For example, a NullPointerException in a method stops its execution, and no further statements are processed. This can lead to data corruption or an unstable application state if critical operations are interrupted.",
            "questionRu": "Как исключения влияют на программу, если их не обрабатывать?",
            "answerRu": "Если исключения в программе на Java не обрабатываются, они приводят к внезапному прерыванию программы в точке возникновения. Система времени выполнения передаёт исключение вверх по стеку вызовов, пока оно не будет поймано или не достигнет вершины, останавливая выполнение. Любой код после исключения в текущем методе или последующих вызовах пропускается, оставляя задачи незавершёнными. Например, NullPointerException в методе останавливает его выполнение, и дальнейшие инструкции не обрабатываются. Это может привести к повреждению данных или нестабильному состоянию приложения, если важные операции прерваны.",
            "category": "Exception Handling",
            "level": "Middle"
        },
        {
            "id": 166,
            "questionEn": "What is the use of the final keyword?",
            "answerEn": "In Java, the final keyword restricts modification, applying to variables, methods, and classes. When used with a variable, it makes it a constant, preventing reassignment after initialization. For a method, final prevents subclasses from overriding it, ensuring its implementation remains unchanged. Applied to a class, it prohibits inheritance, as seen with final class String. For example, final void display() {} in a parent class cannot be overridden by a subclass.",
            "questionRu": "Каково назначение ключевого слова final?",
            "answerRu": "В Java ключевое слово final ограничивает изменения, применяясь к переменным, методам и классам. Для переменной оно делает её константой, запрещая повторное присваивание после инициализации. Для метода final предотвращает его переопределение в подклассах, сохраняя реализацию неизменной. Применённое к классу, оно запрещает наследование, как в случае с final class String. Например, final void display() {} в родительском классе не может быть переопределён подклассом.",
            "category": "Java Core",
            "level": "Middle"
        },
        {
            "id": 167,
            "questionEn": "What purpose do the keywords final, finally, and finalize fulfill?",
            "answerEn": "The final keyword in Java prevents modification, making variables constant, methods non-overridable, and classes non-inheritable. The finally block, used in exception handling with try-catch, executes code regardless of whether an exception occurs, ensuring cleanup tasks like closing resources. The finalize method, defined in the Object class, is called by the garbage collector before an object is reclaimed, allowing cleanup actions. For instance, final int x = 10; cannot be reassigned, while finally runs after a try block, and finalize might print a message before object destruction. These keywords serve distinct purposes: immutability, guaranteed execution, and object lifecycle management.",
            "questionRu": "Какую цель выполняют ключевые слова final, finally и finalize?",
            "answerRu": "Ключевое слово final в Java предотвращает изменения, делая переменные константами, методы не переопределяемыми, а классы не наследуемыми. Блок finally, используемый в обработке исключений с try-catch, выполняет код независимо от возникновения исключения, обеспечивая очистку, например, закрытие ресурсов. Метод finalize, определённый в классе Object, вызывается сборщиком мусора перед уничтожением объекта, позволяя выполнить очистку. Например, final int x = 10; нельзя переприсвоить, finally выполняется после try, а finalize может вывести сообщение перед удалением объекта. Эти ключевые слова служат разным целям: неизменности, гарантированному выполнению и управлению жизненным циклом объекта.",
            "category": "Java Core",
            "level": "Middle"
        },
        {
            "id": 168,
            "questionEn": "What is the difference between this() and super() in Java?",
            "answerEn": "In Java, this() and super() are used to call constructors within a class, but they target different scopes. this() invokes another constructor of the same class, enabling constructor chaining for the current instance. In contrast, super() calls a constructor of the superclass, initializing the parent class portion of the object. For example, this() might call an overloaded constructor in the same class, while super() accesses the parent’s default or parameterized constructor. These calls must be the first statement in a constructor and cannot coexist in the same one.",
            "questionRu": "Чем отличается this() от super() в Java?",
            "answerRu": "В Java this() и super() используются для вызова конструкторов внутри класса, но они относятся к разным областям. this() вызывает другой конструктор того же класса, обеспечивая цепочку конструкторов для текущего экземпляра. Напротив, super() обращается к конструктору суперкласса, инициализируя родительскую часть объекта. Например, this() может вызвать перегруженный конструктор в том же классе, а super() — стандартный или параметризованный конструктор родителя. Эти вызовы должны быть первыми в конструкторе и не могут использоваться вместе в одном.",
            "category": "Object-Oriented Programming (OOP)",
            "level": "Middle"
        },
        {
            "id": 169,
            "questionEn": "What is multitasking?",
            "answerEn": "Multitasking in Java refers to a program’s ability to execute multiple tasks concurrently. This is achieved using threads, which are lightweight processes running within the same program. Threads enable simultaneous execution of different operations, enhancing efficiency in applications like servers or UI programs. For instance, one thread might handle user input while another processes data in the background. Java’s multitasking relies on the Thread class or Runnable interface to manage these parallel tasks.",
            "questionRu": "Что такое многозадачность?",
            "answerRu": "Многозадачность в Java — это способность программы выполнять несколько задач одновременно. Это достигается с помощью потоков, которые являются легковесными процессами внутри одной программы. Потоки позволяют параллельно выполнять различные операции, повышая эффективность в приложениях, таких как серверы или программы с интерфейсом. Например, один поток может обрабатывать ввод пользователя, а другой — выполнять фоновую обработку данных. Многозадачность в Java основана на классе Thread или интерфейсе Runnable для управления параллельными задачами.",
            "category": "Multithreading & Concurrency",
            "level": "Middle"
        },
        {
            "id": 170,
            "questionEn": "What do you mean by a Multithreaded program?",
            "answerEn": "A multithreaded program in Java is one that executes multiple threads concurrently rather than sequentially within a single process. These threads, lightweight units of execution, allow the program to perform several tasks simultaneously, optimizing resource use. This design enables multiple users to interact with the program at once without needing separate instances. By leveraging multithreading, the program can utilize multiple CPU cores, improving performance and throughput. For example, a web server might handle multiple client requests concurrently using threads.",
            "questionRu": "Что значит многопоточная программа?",
            "answerRu": "Многопоточная программа в Java — это программа, выполняющая несколько потоков параллельно, а не последовательно, в рамках одного процесса. Эти потоки, легковесные единицы выполнения, позволяют программе одновременно решать несколько задач, оптимизируя использование ресурсов. Такой подход позволяет нескольким пользователям взаимодействовать с программой одновременно без запуска отдельных копий. Использование многопоточности позволяет задействовать несколько ядер процессора, улучшая производительность и пропускную способность. Например, веб-сервер может обрабатывать запросы нескольких клиентов параллельно с помощью потоков.",
            "category": "Multithreading & Concurrency",
            "level": "Middle"
        },
        {
            "id": 171,
            "questionEn": "What are the advantages of multithreading?",
            "answerEn": "A multithreaded program in Java consists of multiple threads that run concurrently, enabling simultaneous task execution instead of sequential processing. This allows efficient resource utilization, leveraging multiple processors to enhance overall throughput and performance. It supports multiple users accessing the program simultaneously without requiring separate instances. Multithreading improves responsiveness and scalability, making it ideal for I/O-bound or CPU-intensive applications. Java facilitates this with the Thread class and Runnable interface.",
            "questionRu": "Какие преимущества многопоточности?",
            "answerRu": "Многопоточная программа в Java состоит из нескольких потоков, выполняющихся параллельно, что позволяет выполнять задачи одновременно вместо последовательной обработки. Это обеспечивает эффективное использование ресурсов, задействуя несколько процессоров для повышения общей пропускной способности и производительности. Она поддерживает одновременный доступ нескольких пользователей к программе без необходимости создания отдельных экземпляров. Многопоточность улучшает отзывчивость и масштабируемость, что делает ее идеальной для приложений, связанных с вводом-выводом или интенсивным использованием процессора. Java поддерживает это через класс Thread и интерфейс Runnable.",
            "category": "Multithreading & Concurrency",
            "level": "Middle"
        },
        {
            "id": 172,
            "questionEn": "What are the two ways in which Thread can be created?",
            "answerEn": "In Java, a thread can be created in two primary ways. First, by extending the Thread class, where a new class overrides the run() method to define the thread’s task. Second, by implementing the Runnable interface, where a class overrides run() and is passed to a Thread object. In both cases, the thread’s execution begins by calling the start() method on the Thread instance. The Runnable approach is often preferred as it allows greater flexibility by avoiding single inheritance limitations.",
            "questionRu": "Какие два способа создания потока существуют?",
            "answerRu": "В Java поток можно создать двумя основными способами. Первый — через наследование класса Thread, где новый класс переопределяет метод run() для задания задачи потока. Второй — через реализацию интерфейса Runnable, где класс переопределяет run() и передается объекту Thread. В обоих случаях выполнение потока начинается с вызова метода start() на экземпляре Thread. Подход с Runnable часто предпочтительнее, поскольку он обеспечивает большую гибкость, избегая ограничений одиночного наследования.",
            "category": "Multithreading & Concurrency",
            "level": "Middle"
        },
        {
            "id": 173,
            "questionEn": "What is a thread?",
            "answerEn": "A thread in Java is a lightweight subprocess with its own program counter, execution stack, and local variables, enabling concurrent execution within a process. It shares memory with other threads but operates independently, so an exception in one thread does not affect others. This supports efficient multitasking, utilizing CPU resources effectively in multithreaded applications. Java provides built-in support for threads through the Thread class and Runnable interface. Threads enhance performance in I/O-bound or CPU-intensive tasks.",
            "questionRu": "Что такое поток?",
            "answerRu": "Поток в Java — это легковесный подпроцесс с собственным счетчиком программы, стеком выполнения и локальными переменными, обеспечивающий параллельное выполнение внутри процесса. Он использует общую память с другими потоками, но работает независимо, поэтому исключение в одном потоке не влияет на другие. Это поддерживает эффективную многозадачность, оптимально используя ресурсы CPU в многопоточных приложениях. Java предоставляет встроенную поддержку потоков через класс Thread и интерфейс Runnable. Потоки улучшают производительность в задачах, связанных с вводом-выводом или интенсивным использованием процессора.",
            "category": "Multithreading & Concurrency",
            "level": "Middle"
        },
        {
            "id": 174,
            "questionEn": "Differentiate between process and thread?",
            "answerEn": "A process in a computer system is an executing program with its own isolated memory space, while a thread is a smaller unit of execution within a process sharing the same memory. Processes take more time to terminate and switch contexts due to their independent nature, whereas threads terminate and switch faster because they operate within a single process. Processes are less efficient for communication as they are isolated, while threads share data and communicate more effectively. This makes processes suitable for independent tasks and threads ideal for concurrent operations within a program.",
            "questionRu": "Чем отличается процесс от потока?",
            "answerRu": "Процесс в компьютерной системе — это выполняемая программа с собственной изолированной памятью, тогда как нить — это меньшая единица выполнения внутри процесса, использующая общую память. Процессы требуют больше времени для завершения и переключения контекста из-за их независимости, тогда как нити завершаются и переключаются быстрее, поскольку работают в рамках одного процесса. Процессы менее эффективны в коммуникации из-за изоляции, в то время как нити обмениваются данными и взаимодействуют более эффективно. Это делает процессы подходящими для независимых задач, а нити — для параллельных операций внутри программы.",
            "category": "Multithreading & Concurrency",
            "level": "Middle"
        },
        {
            "id": 175,
            "questionEn": "Describe the life cycle of the thread?",
            "answerEn": "The life cycle of a thread in Java includes several distinct states it transitions through during its execution. It begins in the New state when created but not yet started, moving to the Runnable state when it is either running or ready to run. A thread enters the Blocked or Waiting state when it pauses for resources or another thread’s action, resuming when conditions are met. Finally, it reaches the Terminated state upon completing its task or being stopped. This cycle allows efficient management of concurrent tasks in multithreaded applications.",
            "questionRu": "Опиши жизненный цикл потока?",
            "answerRu": "Жизненный цикл потока в Java включает несколько отдельных состояний, через которые он проходит во время выполнения. Он начинается в состоянии New, когда поток создан, но еще не запущен, переходя в состояние Runnable, когда он либо выполняется, либо готов к запуску. Поток переходит в состояние Blocked или Waiting, когда приостанавливается из-за ожидания ресурсов или действия другого потока, возобновляясь при выполнении условий. Наконец, он достигает состояния Terminated по завершении задачи или принудительной остановке. Этот цикл позволяет эффективно управлять параллельными задачами в многопоточных приложениях.",
            "category": "Multithreading & Concurrency",
            "level": "Middle"
        },
        {
            "id": 176,
            "questionEn": "Explain suspend() method under the Thread class.",
            "answerEn": "The suspend() method in the Thread class temporarily halts a thread’s execution, moving it to a blocked state where it cannot be scheduled by the operating system. This pause persists until the thread is resumed using the resume() method, allowing control over its lifecycle. However, suspend() is deprecated in modern Java due to risks like deadlocks and is replaced by safer alternatives like wait() and notify(). It does not return any value and should be avoided in favor of synchronized blocks or higher-level concurrency utilities. This reflects Java’s shift toward more robust multithreading practices.",
            "questionRu": "Объясни метод suspend() в классе Thread.",
            "answerRu": "Метод suspend() в классе Thread временно приостанавливает выполнение потока, переводя его в состояние блокировки, где он не может быть запланирован операционной системой. Эта пауза сохраняется до возобновления потока с помощью метода resume(), что позволяет управлять его жизненным циклом. Однако suspend() считается устаревшим в современной Java из-за риска взаимных блокировок и заменен более безопасными альтернативами, такими как wait() и notify(). Он не возвращает значение и не рекомендуется к использованию в пользу синхронизированных блоков или утилит высшего уровня для работы с потоками. Это отражает переход Java к более надежным практикам многопоточности.",
            "category": "Multithreading & Concurrency",
            "level": "Middle"
        },
        {
            "id": 177,
            "questionEn": "Explain the main thread under Thread class execution.",
            "answerEn": "The main thread in Java is the initial thread automatically created when a program starts, executing the main() method. It serves as the parent thread, spawning and managing all other threads during program execution. This thread handles the core logic and user input operations, ensuring the program’s primary flow. Java’s built-in multithreading support allows the main thread to coordinate concurrent tasks effectively. Its termination typically signals the end of the application.",
            "questionRu": "Объясни главный поток в выполнении класса Thread.",
            "answerRu": "Главный поток в Java — это начальный поток, автоматически создаваемый при запуске программы, который выполняет метод main(). Он выступает родительским потоком, порождая и управляющим всеми остальными потоками во время выполнения программы. Этот поток обрабатывает основную логику и операции ввода от пользователя, обеспечивая основной поток программы. Встроенная поддержка многопоточности в Java позволяет главному потоку эффективно координировать параллельные задачи. Его завершение обычно указывает на окончание работы приложения.",
            "category": "Multithreading & Concurrency",
            "level": "Middle"
        },
        {
            "id": 178,
            "questionEn": "What is a daemon thread?",
            "answerEn": "A daemon thread in Java is a low-priority thread that performs background tasks continuously, such as garbage collection or signal dispatching. It runs only when no user threads are active, ensuring it does not interfere with primary program operations. Daemon threads are ideal for non-critical tasks that do not require explicit shutdown, like logging or monitoring. They automatically terminate when all user threads finish, allowing efficient resource management. You can set a thread as a daemon using the setDaemon(true) method before starting it.",
            "questionRu": "Что такое поток-демон?",
            "answerRu": "Демон-поток в Java — это низкоприоритетный поток, выполняющий фоновые задачи непрерывно, например, сборку мусора или обработку сигналов. Он работает только тогда, когда активных пользовательских потоков нет, не мешая основным операциям программы. Демон-потоки идеальны для некритичных задач, не требующих явного завершения, таких как логирование или мониторинг. Они автоматически завершаются, когда все пользовательские потоки заканчивают работу, что способствует эффективному управлению ресурсами. Установить поток как демон можно с помощью метода setDaemon(true) перед его запуском.",
            "category": "Multithreading & Concurrency",
            "level": "Middle"
        },
        {
            "id": 179,
            "questionEn": "What are the ways in which a thread can enter the waiting state?",
            "answerEn": "A thread in Java enters the waiting state when its execution is paused, such as through the sleep() method, which suspends it for a specified time. It can also wait using the wait() method until notified by another thread or the join() method until a target thread completes. Additionally, a thread waits during I/O operations until they finish or due to synchronization issues, such as waiting for a lock in a multithreaded environment. These mechanisms ensure coordinated execution among threads. Each state transition is managed by the Java runtime to optimize resource usage.",
            "questionRu": "Какие есть способы перевода потока в состояние ожидания?",
            "answerRu": "Поток в Java переходит в состояние ожидания, когда его выполнение приостанавливается, например, с помощью метода sleep(), который suspend() на заданное время. Он также может ждать с использованием метода wait() до уведомления от другого потока или метода join() до завершения целевого потока. Кроме того, поток ожидает во время операций ввода-вывода до их завершения или из-за проблем синхронизации, таких как ожидание блокировки в многопоточной среде. Эти механизмы обеспечивают скоординированное выполнение потоков. Каждый переход состояния управляется средой выполнения Java для оптимизации использования ресурсов.",
            "category": "Multithreading & Concurrency",
            "level": "Middle"
        },
        {
            "id": 180,
            "questionEn": "How does multi-threading take place on a computer with a single CPU?",
            "answerEn": "Multi-threading on a single-CPU computer is achieved through time-sharing, where the CPU rapidly switches between threads to create an illusion of parallel execution. The operating system allocates small time slices to each thread, scheduling them sequentially to ensure all active threads get CPU time. Java manages thread interactions with synchronization and locking mechanisms to prevent race conditions and ensure correct execution. However, this approach only simulates parallelism, offering limited performance gains compared to multi-CPU systems. The switching occurs so quickly (in milliseconds or microseconds) that it appears seamless to the user.",
            "questionRu": "Как многопоточность работает на компьютере с одним CPU?",
            "answerRu": "Многопоточность на компьютере с одним CPU реализуется через тайм-шейринг, при котором CPU быстро переключается между потоками, создавая иллюзию параллельного выполнения. Операционная система выделяет небольшие временные интервалы каждому потоку, планируя их последовательное выполнение, чтобы все активные потоки получали время CPU. Java управляет взаимодействием потоков с помощью механизмов синхронизации и блокировки, предотвращая условия гонки и обеспечивая корректное выполнение. Однако этот подход лишь имитирует параллелизм, предоставляя ограниченный прирост производительности по сравнению с системами с несколькими CPU. Переключение происходит настолько быстро (в миллисекундах или микросекундах), что кажется seamless пользователю.",
            "category": "Multithreading & Concurrency",
            "level": "Middle"
        },
        {
            "id": 181,
            "questionEn": "What are the different types of Thread Priorities in Java? And what is the default priority of a thread assigned by JVM?",
            "answerEn": "In Java, thread priorities determine the scheduling preference of threads, represented by numbers from 1 to 10. The Thread class defines three priority types: MIN_PRIORITY (value 1), MAX_PRIORITY (value 10), and NORM_PRIORITY (value 5). By default, the JVM assigns a thread the NORM_PRIORITY, which is 5, ensuring balanced execution. Higher-priority threads are scheduled before lower-priority ones, though this depends on the underlying operating system. These priorities help optimize thread execution in multithreaded applications.",
            "questionRu": "Какие типы приоритетов потоков есть в Java? Какой приоритет по умолчанию назначает JVM?",
            "answerRu": "В Java приоритеты потоков определяют предпочтение при планировании потоков, представленное числами от 1 до 10. Класс Thread определяет три типа приоритетов: MIN_PRIORITY (значение 1), MAX_PRIORITY (значение 10) и NORM_PRIORITY (значение 5). По умолчанию JVM присваивает потоку приоритет NORM_PRIORITY, равный 5, обеспечивая сбалансированное выполнение. Потоки с более высоким приоритетом планируются раньше, чем с более низким, хотя это зависит от операционной системы. Эти приоритеты помогают оптимизировать выполнение потоков в многопоточных приложениях.",
            "category": "Multithreading & Concurrency",
            "level": "Senior"
        },
        {
            "id": 182,
            "questionEn": "Why Garbage Collection is necessary in Java?",
            "answerEn": "Garbage collection in Java is essential to prevent memory leaks, which can lead to program crashes and instability. It automatically frees up memory by removing unreferenced objects from the heap, making Java memory-efficient. The Java Virtual Machine (JVM) periodically runs the garbage collector to manage memory without manual intervention. This allows developers to focus on application logic rather than memory management. As a result, garbage collection enhances the reliability and performance of Java applications.",
            "questionRu": "Почему сборка мусора необходима в Java?",
            "answerRu": "Сборка мусора в Java необходима для предотвращения утечек памяти, которые могут привести к сбоям программы и нестабильности. Она автоматически освобождает память, удаляя неиспользуемые объекты из кучи, что делает Java эффективной в управлении памятью. Виртуальная машина Java (JVM) периодически запускает сборщик мусора для управления памятью без ручного вмешательства. Это позволяет разработчикам сосредоточиться на логике приложения, а не на управлении памятью. В результате сборка мусора повышает надежность и производительность приложений Java.",
            "category": "JVM Memory Management & Garbage Collection",
            "level": "Senior"
        },
        {
            "id": 183,
            "questionEn": "What is the drawback of Garbage Collection?",
            "answerEn": "A major drawback of garbage collection in Java is that it can cause execution pauses while clearing memory, potentially slowing application performance. Its non-deterministic nature makes it hard to predict when it occurs, leading to unpredictable behavior and complicating debugging efforts. Additionally, frequent creation and disposal of short-lived objects can increase memory usage despite garbage collection. These issues can impact real-time applications requiring consistent performance. Developers must optimize code to mitigate these effects.",
            "questionRu": "Какой недостаток у сборки мусора?",
            "answerRu": "Основной недостаток сборки мусора в Java заключается в том, что она может вызывать паузы во время выполнения при очистке памяти, что замедляет работу приложения. Ее непредсказуемый характер затрудняет определение времени срабатывания, что приводит к непредсказуемому поведению и усложняет отладку. Кроме того, частое создание и удаление объектов с коротким жизненным циклом может увеличить потребление памяти, несмотря на сборку мусора. Эти проблемы могут влиять на приложения реального времени, требующие стабильной производительности. Разработчикам необходимо оптимизировать код для минимизации этих эффектов.",
            "category": "JVM Memory Management & Garbage Collection",
            "level": "Senior"
        },
        {
            "id": 184,
            "questionEn": "Explain the difference between a minor, major, and full garbage collection.",
            "answerEn": "Minor garbage collection targets the young generation, reclaiming memory used by short-lived objects that are quickly created and discarded. Major garbage collection focuses on the old generation, cleaning up long-lived objects that have survived multiple minor collections. Full garbage collection involves both young and old generations, reclaiming memory across all areas but taking longer to complete. The extended duration of full garbage collection often causes temporary pauses in the application, impacting performance more than minor or major collections. These types allow the JVM to optimize memory management based on object longevity.",
            "questionRu": "Объясни разницу между minor, major и full сборкой мусора.",
            "answerRu": "Малая сборка мусора нацелена на молодое поколение, освобождая память, занятую краткоживущими объектами, которые быстро создаются и удаляются. Большая сборка мусора фокусируется на старом поколении, очищая долгоживущие объекты, пережившие несколько малых сборок. Полная сборка мусора охватывает как молодое, так и старое поколения, освобождая память по всем областям, но занимает больше времени. Длительность полной сборки мусора часто вызывает временные паузы в приложении, влияя на производительность сильнее, чем малая или большая сборка. Эти типы позволяют JVM оптимизировать управление памятью в зависимости от времени жизни объектов.",
            "category": "JVM Memory Management & Garbage Collection",
            "level": "Senior"
        },
        {
            "id": 185,
            "questionEn": "How will you identify major and minor garbage collections in Java?",
            "answerEn": "In Java, minor garbage collection operates on the Eden space in the young generation, targeting short-lived objects, while major garbage collection focuses on the survivor and old generation spaces for long-lived objects. You can identify them by enabling garbage collection logging with JVM flags like -XX:+PrintGCDetails or -verbose:gc. When logging is enabled, minor garbage collection is indicated by “GC” in the output, whereas major garbage collection is marked as “Full GC.” This distinction helps developers monitor and analyze memory management behavior. Using tools like VisualVM or JConsole can further assist in tracking these events.",
            "questionRu": "Как определить major и minor сборки мусора в Java?",
            "answerRu": "В Java малая сборка мусора работает с пространством Eden в молодом поколении, нацеливаясь на краткоживущие объекты, тогда как большая сборка мусора охватывает пространства survivor и старого поколения для долгоживущих объектов. Их можно определить, включив логирование сборки мусора с помощью флагов JVM, таких как -XX:+PrintGCDetails или -verbose:gc. При включенном логировании малая сборка мусора обозначается как “GC” в выводе, а большая — как “Full GC.” Это различие помогает разработчикам отслеживать и анализировать поведение управления памятью. Использование инструментов, таких как VisualVM или JConsole, может дополнительно помочь в мониторинге этих событий.",
            "category": "JVM Memory Management & Garbage Collection",
            "level": "Senior"
        },
        {
            "id": 186,
            "questionEn": "What is a memory leak, and how does it affect garbage collection?",
            "answerEn": "A memory leak in Java occurs when objects with valid references are no longer needed but remain in memory, preventing garbage collection from reclaiming them. It is often caused by failing to close resources, holding references too long, or creating excessive objects. This negatively affects garbage collection by reducing available heap space, leading to slower performance or OutOfMemoryError. Proper resource management and timely reference release are essential to avoid memory leaks. Monitoring tools like VisualVM can help detect and mitigate such issues.",
            "questionRu": "Что такое утечка памяти и как она влияет на сборку мусора?",
            "answerRu": "Утечка памяти в Java возникает, когда объекты с действительными ссылками больше не нужны, но остаются в памяти, препятствуя сборке мусора освобождать их. Она часто вызывается неправильным закрытием ресурсов, длительным удержанием ссылок или созданием избыточных объектов. Это негативно сказывается на сборке мусора, уменьшая доступное пространство кучи и приводя к замедлению или ошибке OutOfMemoryError. Правильное управление ресурсами и своевременное освобождение ссылок необходимо для предотвращения утечек. Инструменты мониторинга, такие как VisualVM, помогают выявлять и устранять такие проблемы.",
            "category": "JVM Memory Management & Garbage Collection",
            "level": "Senior"
        },
        {
            "id": 187,
            "questionEn": "Name some classes present in java.util.regex package.",
            "answerEn": "The java.util.regex package includes the Pattern class, which defines regular expression patterns for string matching. The Matcher class performs match operations on text using these patterns, enabling data extraction or validation. The PatternSyntaxException class signals syntax errors in regular expression patterns, aiding debugging. Additionally, the package features the MatchResult interface, which represents the results of a match operation. These components collectively support powerful string manipulation in Java.",
            "questionRu": "Назови классы из пакета java.util.regex.",
            "answerRu": "Пакет java.util.regex включает класс Pattern, который определяет шаблоны регулярных выражений для сопоставления строк. Класс Matcher выполняет операции сопоставления текста с использованием этих шаблонов, позволяя извлекать данные или проверять корректность. Класс PatternSyntaxException указывает на синтаксические ошибки в шаблонах регулярных выражений, помогая в отладке. Кроме того, пакет содержит интерфейс MatchResult, представляющий результаты операции сопоставления. Эти компоненты совместно обеспечивают мощные возможности манипуляции строками в Java.",
            "category": "Java Core",
            "level": "Senior"
        },
        {
            "id": 188,
            "questionEn": "Write a regular expression to validate a password. A password must start with an alphabet and followed by alphanumeric characters; Its length must be in between 8 to 20.",
            "answerEn": "To validate a password in Java that starts with an alphabet and is followed by alphanumeric characters with a length of 8 to 20, use the regex ^[a-zA-Z][a-zA-Z0-9]{7,19}$. The ^ asserts the start, [a-zA-Z] ensures the first character is a letter, and [a-zA-Z0-9]{7,19} allows 7 to 19 additional alphanumeric characters. This ensures the total length is between 8 and 20, with no spaces or special characters permitted. The $ marks the end of the string, enforcing the pattern fully matches. This regex meets the requirement efficiently and precisely.",
            "questionRu": "Напиши регулярное выражение для проверки пароля. Пароль должен начинаться с буквы, содержать буквенно-цифровые символы, длина 8-20.",
            "answerRu": "Для проверки пароля в Java, который начинается с буквы и содержит буквенно-цифровые символы длиной от 8 до 20, используйте регулярное выражение ^[a-zA-Z][a-zA-Z0-9]{7,19}$. ^ обозначает начало, [a-zA-Z] гарантирует, что первый символ — буква, а [a-zA-Z0-9]{7,19} допускает от 7 до 19 дополнительных буквенно-цифровых символов. Это обеспечивает общую длину от 8 до 20 без пробелов или спецсимволов. $ указывает конец строки, требуя полного соответствия шаблону. Это регулярное выражение точно и эффективно соответствует заданным условиям.",
            "category": "Java Core",
            "level": "Senior"
        },
        {
            "id": 189,
            "questionEn": "What is JDBC?",
            "answerEn": "JDBC (Java Database Connectivity) is a standard API in Java for connecting Java applications to relational databases. It provides a set of classes and interfaces in the java.sql package to enable database operations like querying and updating. JDBC allows developers to write database-agnostic code, sending SQL requests to any compatible database. Its architecture includes components like the Driver Manager and specific drivers to facilitate this interaction. This API enhances portability and simplifies database access in Java programs.",
            "questionRu": "Что такое JDBC?",
            "answerRu": "JDBC (Java Database Connectivity) — это стандартный API в Java для соединения приложений Java с реляционными базами данных. Он предоставляет набор классов и интерфейсов в пакете java.sql для выполнения операций с базами данных, таких как запросы и обновления. JDBC позволяет разработчикам писать код, независимый от конкретной базы данных, отправляя SQL-запросы к любой совместимой базе. Его архитектура включает компоненты, такие как Driver Manager и специфические драйверы, для обеспечения взаимодействия. Этот API повышает переносимость и упрощает доступ к базам данных в программах на Java.",
            "category": "JDBC & Databases",
            "level": "Senior"
        },
        {
            "id": 190,
            "questionEn": "What is JDBC Driver?",
            "answerEn": "A JDBC Driver is a software component that enables a Java application to connect to and interact with a database. It implements the JDBC API for a specific database management system, facilitating actions like executing SQL queries and retrieving results. Each driver translates Java calls into database-specific protocols, ensuring seamless communication. JDBC drivers come in various types, such as bridge, native, network, and thin drivers, tailored to different connectivity needs. This component is essential for database operations in Java programs.",
            "questionRu": "Что такое JDBC Driver?",
            "answerRu": "JDBC Driver — это программный компонент, позволяющий Java-приложению подключаться к базе данных и взаимодействовать с ней. Он реализует JDBC API для конкретной системы управления базами данных, обеспечивая выполнение SQL-запросов и получение результатов. Каждый драйвер переводит вызовы Java в специфические протоколы базы данных, гарантируя бесперебойное взаимодействие. JDBC-драйверы бывают разных типов, таких как мостовые, нативные, сетевые и тонкие, адаптированные под разные потребности подключения. Этот компонент критически важен для операций с базами данных в Java-программах.",
            "category": "JDBC & Databases",
            "level": "Senior"
        },
        {
            "id": 191,
            "questionEn": "What are the steps to connect to the database in Java?",
            "answerEn": "To connect a Java program to a database using JDBC, start by importing the java.sql package for necessary classes and interfaces. Next, load and register the database driver using Class.forName() or DriverManager.registerDriver() to enable connectivity. Establish a connection with DriverManager.getConnection(), providing the database URL, username, and password. Then, create a Statement object to execute SQL queries and process the results. Finally, close the connection with close() to release resources and prevent leaks.",
            "questionRu": "Какие шаги для подключения к базе данных в Java?",
            "answerRu": "Для подключения программы на Java к базе данных через JDBC сначала импортируйте пакет java.sql для необходимых классов и интерфейсов. Затем загрузите и зарегистрируйте драйвер базы данных с помощью Class.forName() или DriverManager.registerDriver() для обеспечения подключения. Установите соединение через DriverManager.getConnection(), указав URL базы данных, имя пользователя и пароль. Далее создайте объект Statement для выполнения SQL-запросов и обработки результатов. Наконец, закройте соединение методом close(), чтобы освободить ресурсы и избежать утечек.",
            "category": "JDBC & Databases",
            "level": "Senior"
        },
        {
            "id": 192,
            "questionEn": "What are the JDBC API components?",
            "answerEn": "The JDBC API comprises a set of interfaces and classes in the java.sql package for interacting with relational databases. Key components include DriverManager for establishing connections and Connection for managing database sessions. The Statement, PreparedStatement, and CallableStatement interfaces enable execution of SQL queries and stored procedures. The ResultSet interface provides methods to retrieve and process query results. Together, these components facilitate database operations like connecting, querying, and updating in a standardized way.",
            "questionRu": "Какие компоненты JDBC API?",
            "answerRu": "JDBC API состоит из набора интерфейсов и классов в пакете java.sql для взаимодействия с реляционными базами данных. Основные компоненты включают DriverManager для установления соединений и Connection для управления сессиями базы данных. Интерфейсы Statement, PreparedStatement и CallableStatement позволяют выполнять SQL-запросы и хранимые процедуры. Интерфейс ResultSet предоставляет методы для получения и обработки результатов запросов. Вместе эти компоненты обеспечивают стандартизированные операции с базой данных, такие как подключение, запросы и обновление.",
            "category": "JDBC & Databases",
            "level": "Senior"
        },
        {
            "id": 193,
            "questionEn": "What is JDBC Connection interface?",
            "answerEn": "The Connection interface in JDBC, part of the java.sql package, represents a session between a Java application and a database. It is obtained through DriverManager.getConnection() after a JDBC driver is loaded, establishing a link to the database. This interface provides methods like createStatement() and prepareStatement() to execute SQL queries. It also manages transactions with methods like commit() and rollback(), ensuring data integrity. The Connection relies on database-specific drivers to facilitate this interaction seamlessly.",
            "questionRu": "Что такое интерфейс JDBC Connection?",
            "answerRu": "Интерфейс Connection в JDBC, входящий в пакет java.sql, представляет сессию между Java-приложением и базой данных. Он создаётся через DriverManager.getConnection() после загрузки JDBC-драйвера, устанавливая соединение с базой данных. Этот интерфейс предоставляет методы, такие как createStatement() и prepareStatement(), для выполнения SQL-запросов. Он также управляет транзакциями с помощью методов commit() и rollback(), обеспечивая целостность данных. Connection зависит от специфичных для базы данных драйверов для бесперебойного взаимодействия.",
            "category": "JDBC & Databases",
            "level": "Senior"
        },
        {
            "id": 194,
            "questionEn": "What does the JDBC ResultSet interface?",
            "answerEn": "The JDBC ResultSet interface in Java represents a table of data retrieved from a database query. It allows a Java program to access and manipulate this data using a cursor, initially positioned before the first row. The next() method moves the cursor forward, enabling iteration through the rows. ResultSet also supports updating database records directly via methods like updateXXX(), provided the result set is updatable. This interface is essential for handling query results in JDBC applications.",
            "questionRu": "Что делает интерфейс JDBC ResultSet?",
            "answerRu": "Интерфейс JDBC ResultSet в Java представляет таблицу данных, полученных из запроса к базе данных. Он позволяет программе на Java получать доступ к этим данным и управлять ими с помощью курсора, изначально расположенного перед первой строкой. Метод next() перемещает курсор вперед, обеспечивая итерацию по строкам. ResultSet также поддерживает обновление записей в базе данных через методы вроде updateXXX(), если результат доступен для изменений. Этот интерфейс необходим для обработки результатов запросов в приложениях JDBC.",
            "category": "JDBC & Databases",
            "level": "Senior"
        },
        {
            "id": 195,
            "questionEn": "What is the JDBC Rowset?",
            "answerEn": "The JDBC RowSet interface in Java, part of the java.sql package, represents a tabular data structure for storing query results. Unlike ResultSet, it maintains a persistent connection to the data source throughout its lifecycle or can operate disconnected. RowSet enhances flexibility by supporting features like scrolling and updates in a more convenient way. It is implemented in five categories: JdbcRowSet, CachedRowSet, WebRowSet, FilteredRowSet, and JoinRowSet. These implementations cater to various needs, such as offline data manipulation or joining multiple datasets.",
            "questionRu": "Что такое JDBC RowSet?",
            "answerRu": "Интерфейс JDBC RowSet в Java, входящий в пакет java.sql, представляет табличную структуру данных для хранения результатов запросов. В отличие от ResultSet, он поддерживает постоянное соединение с источником данных на протяжении всего жизненного цикла или может работать в отключенном режиме. RowSet повышает гибкость, упрощая прокрутку и обновление данных. Он реализован в пяти категориях: JdbcRowSet, CachedRowSet, WebRowSet, FilteredRowSet и JoinRowSet. Эти реализации удовлетворяют различные потребности, такие как автономная обработка данных или объединение нескольких наборов данных.",
            "category": "JDBC & Databases",
            "level": "Senior"
        },
        {
            "id": 196,
            "questionEn": "What is the role of the JDBC DriverManager class?",
            "answerEn": "The JDBC DriverManager class in Java serves as a central manager for establishing database connections. It facilitates communication between a Java application and JDBC drivers by maintaining a list of registered drivers. Using the getConnection() method, it matches the appropriate driver to the database URL and creates a connection. It also provides methods like registerDriver() and deregisterDriver() to manage driver availability. This class is fundamental for initializing JDBC interactions in a program.",
            "questionRu": "Какова роль класса JDBC DriverManager?",
            "answerRu": "Класс JDBC DriverManager в Java выполняет роль центрального менеджера для установления соединений с базой данных. Он обеспечивает взаимодействие между приложением на Java и драйверами JDBC, поддерживая список зарегистрированных драйверов. С помощью метода getConnection() он подбирает подходящий драйвер для URL базы данных и создает соединение. Также он предоставляет методы registerDriver() и deregisterDriver() для управления доступностью драйверов. Этот класс необходим для инициализации взаимодействия с JDBC в программе.",
            "category": "JDBC & Databases",
            "level": "Senior"
        },
        {
            "id": 197,
            "questionEn": "Differentiate between Iterable and Iterator.",
            "answerEn": "In Java, Iterable is an interface that enables a collection to be iterated over, providing the iterator() method to return an Iterator. Iterator, conversely, is an interface that performs the actual iteration over a collection’s elements sequentially. Iterable is implemented by classes like List, Set, and Queue, marking them as iterable objects. Iterator defines hasNext() to check for more elements, next() to retrieve the next element, and an optional remove() method. Thus, Iterable sets the capability, while Iterator executes the traversal process.",
            "questionRu": "Чем отличается Iterable от Iterator?",
            "answerRu": "В Java интерфейс Iterable позволяет итерироваться по коллекции, предоставляя метод iterator() для возврата объекта Iterator. Iterator, напротив, — это интерфейс, который выполняет непосредственную последовательную итерацию по элементам коллекции. Iterable реализуется классами, такими как List, Set и Queue, обозначая их как итерируемые объекты. Iterator определяет методы hasNext() для проверки наличия элементов, next() для получения следующего элемента и необязательный remove(). Таким образом, Iterable задает возможность, а Iterator реализует процесс обхода.",
            "category": "Collections",
            "level": "Junior"
        },
        {
            "id": 198,
            "questionEn": "Differentiate between List and Set.",
            "answerEn": "In Java, List is an ordered collection that allows duplicate elements and access via index. Set, in contrast, is an unordered collection that prohibits duplicates, relying on hash codes for element access. List implementations, like ArrayList and LinkedList, can store multiple null values and maintain insertion order. Set implementations, such as HashSet and TreeSet, permit only one null element and prioritize uniqueness over order. These differences make List suitable for ordered sequences and Set for distinct collections.",
            "questionRu": "Чем отличается List от Set?",
            "answerRu": "В Java List — это упорядоченная коллекция, допускающая дубликаты и доступ по индексу. Set, напротив, — неупорядоченная коллекция, запрещающая дубликаты, с доступом через хэш-коды. Реализации List, такие как ArrayList и LinkedList, могут содержать несколько null-значений и сохранять порядок вставки. Реализации Set, например HashSet и TreeSet, разрешают только одно null-значение и ставят уникальность выше порядка. Эти различия делают List подходящим для упорядоченных последовательностей, а Set — для уникальных коллекций.",
            "category": "Collections",
            "level": "Junior"
        },
        {
            "id": 199,
            "questionEn": "Differentiate between List and Map.",
            "answerEn": "In Java, List is an ordered collection interface that permits duplicate elements and allows multiple null values. Map, however, is a key-value mapping interface that prohibits duplicate keys, allowing only one null key but any number of null values. List maintains insertion order and provides the get() method for index-based access, as seen in implementations like ArrayList. Map does not preserve order by default and uses keys for access, not indices, with implementations like HashMap and TreeMap. These distinctions make List ideal for sequences and Map for key-based lookups.",
            "questionRu": "Чем отличается List от Map?",
            "answerRu": "В Java List — это упорядоченный интерфейс коллекции, допускающий дубликаты и несколько null-значений. Map, напротив, — это интерфейс отображения ключ-значение, запрещающий дубликаты ключей, с ограничением в один null-ключ, но любым количеством null-значений. List сохраняет порядок вставки и предоставляет метод get() для доступа по индексу, как в реализациях вроде ArrayList. Map не сохраняет порядок по умолчанию и использует ключи для доступа, а не индексы, с реализациями вроде HashMap и TreeMap. Эти различия делают List подходящим для последовательностей, а Map — для поиска по ключам.",
            "category": "Collections",
            "level": "Junior"
        },
        {
            "id": 200,
            "questionEn": "Differentiate between Queue and Stack.",
            "answerEn": "In Java, a Queue is a data structure that follows FIFO (First In, First Out) order, where elements are added (enqueued) at the rear and removed (dequeued) from the front. A Stack, conversely, operates on LIFO (Last In, First Out) order, with elements pushed and popped from the top. Queue supports operations at opposite ends, making it ideal for sequential processing tasks. Stack performs insertions and deletions at one end, suiting recursive problem-solving scenarios. These distinct behaviors define their roles in the Collections Framework.",
            "questionRu": "Чем отличается Queue от Stack?",
            "answerRu": "В Java Queue — это структура данных, следующая порядку FIFO (первым пришел, первым ушел), где элементы добавляются (enqueue) в конец и удаляются (dequeue) с начала. Stack, напротив, работает по принципу LIFO (последним пришел, первым ушел), с добавлением (push) и удалением (pop) с вершины. Queue поддерживает операции на противоположных концах, что делает его идеальным для задач последовательной обработки. Stack выполняет вставку и удаление с одного конца, подходя для решения рекурсивных задач. Эти различия определяют их роли в Collections Framework.",
            "category": "Collections",
            "level": "Junior"
        },
        {
            "id": 201,
            "questionEn": "Differentiate between PriorityQueue and TreeSet.",
            "answerEn": "PriorityQueue in Java is a queue-based structure that orders elements by priority, implemented by the PriorityQueue class since JDK 1.5. TreeSet, conversely, is a set-based structure that maintains a sorted order, implemented by the TreeSet class since JDK 1.4. PriorityQueue allows duplicate elements, while TreeSet ensures uniqueness by rejecting duplicates. PriorityQueue uses a heap internally for priority ordering, whereas TreeSet relies on a red-black tree for natural or custom sorting. These differences make PriorityQueue suited for priority tasks and TreeSet for sorted, unique collections.",
            "questionRu": "Чем отличается PriorityQueue от TreeSet?",
            "answerRu": "PriorityQueue в Java — это структура на основе очереди, упорядочивающая элементы по приоритету, реализованная классом PriorityQueue с JDK 1.5. TreeSet, напротив, — это структура на основе множества, поддерживающая сортированный порядок, реализованная классом TreeSet с JDK 1.4. PriorityQueue допускает дубликаты, тогда как TreeSet гарантирует уникальность, отклоняя повторы. PriorityQueue использует кучу для приоритетного порядка, а TreeSet опирается на красно-черное дерево для естественной или пользовательской сортировки. Эти различия делают PriorityQueue подходящим для задач с приоритетами, а TreeSet — для сортированных уникальных коллекций.",
            "category": "Collections",
            "level": "Junior"
        },
        {
            "id": 202,
            "questionEn": "Differentiate between the Singly Linked List and Doubly Linked List.",
            "answerEn": "A Singly Linked List in Java consists of nodes with data and one pointer to the next node, allowing traversal only forward. A Doubly Linked List, however, has nodes with data and two pointers, enabling traversal in both forward and backward directions. Singly Linked List uses less memory due to its single pointer per node, while Doubly Linked List requires more memory for dual pointers. Insertion and deletion in a Singly Linked List have O(n) time complexity, whereas Doubly Linked List achieves O(1) for operations at known positions. These differences affect their suitability for specific use cases like navigation or memory efficiency.",
            "questionRu": "Чем отличается односвязный список от двусвязного списка?",
            "answerRu": "Односвязный список в Java состоит из узлов с данными и одним указателем на следующий узел, разрешая обход только вперед. Двусвязный список, напротив, имеет узлы с данными и двумя указателями, позволяя обход в обоих направлениях — вперед и назад. Односвязный список использует меньше памяти благодаря одному указателю на узел, тогда как двусвязный список требует больше памяти из-за двух указателей. Вставка и удаление в односвязном списке имеют сложность O(n), а в двусвязном — O(1) для операций на известных позициях. Эти различия влияют на их применимость для задач вроде навигации или эффективности памяти.",
            "category": "Data Structures",
            "level": "Junior"
        },
        {
            "id": 203,
            "questionEn": "Differentiate between Failfast and Failsafe.",
            "answerEn": "Failfast and Failsafe describe iterator behaviors in Java when a collection is modified during iteration. Failfast iterators, used in single-threaded environments, immediately throw a ConcurrentModificationException if the collection changes. Failsafe iterators, common in multithreaded contexts, allow modifications by iterating over a copy of the collection, avoiding exceptions. Failfast is faster as it doesn’t involve copying, while Failsafe is slower due to the overhead of duplication. These traits make Failfast strict and efficient, and Failsafe flexible but resource-intensive.",
            "questionRu": "Чем отличается FailFast от FailSafe?",
            "answerRu": "Failfast и Failsafe описывают поведение итераторов в Java при изменении коллекции во время итерации. Failfast-итераторы, применяемые в однопоточных средах, немедленно выбрасывают ConcurrentModificationException при изменении коллекции. Failsafe-итераторы, используемые в многопоточных контекстах, разрешают модификации, итерируясь по копии коллекции, избегая исключений. Failfast быстрее, так как не требует копирования, тогда как Failsafe медленнее из-за затрат на дублирование. Эти свойства делают Failfast строгим и эффективным, а Failsafe — гибким, но ресурсоемким.",
            "category": "Collections",
            "level": "Junior"
        },
        {
            "id": 204,
            "questionEn": "Differentiate between HashMap and TreeMap.",
            "answerEn": "HashMap in Java uses a hash table to store key-value pairs, offering no guaranteed order for iteration. TreeMap, in contrast, employs a red-black tree to maintain keys in a natural or custom sorted order. HashMap provides faster retrieval due to its hash-based lookup, while TreeMap is slower as it relies on tree traversal. HashMap uses equals() to compare keys, whereas TreeMap uses compareTo() for ordering. These differences make HashMap ideal for quick access and TreeMap for sorted data needs.",
            "questionRu": "Чем отличается HashMap от TreeMap?",
            "answerRu": "HashMap в Java использует хэш-таблицу для хранения пар ключ-значение, не гарантируя порядка при итерации. TreeMap, напротив, применяет красно-черное дерево, поддерживая ключи в естественном или заданном порядке сортировки. HashMap обеспечивает более быструю выборку благодаря хэш-поиску, тогда как TreeMap медленнее из-за обхода дерева. HashMap использует equals() для сравнения ключей, а TreeMap — compareTo() для упорядочивания. Эти различия делают HashMap подходящим для быстрого доступа, а TreeMap — для задач с сортированными данными.",
            "category": "Collections",
            "level": "Junior"
        },
        {
            "id": 205,
            "questionEn": "Differentiate between Queue and Deque.",
            "answerEn": "A Queue in Java is a linear data structure that stores elements, allowing insertion only at the rear and removal from the front. Deque, or Double-ended Queue, extends this by permitting insertions and removals at both ends. Queue follows a FIFO (First In, First Out) order and can be implemented using arrays or linked lists. Deque, implemented with circular arrays or doubly linked lists, supports more flexible operations like stack or dual-end dequeuing. Queue suits sequential tasks like waiting lists, while Deque fits scenarios needing bidirectional access.",
            "questionRu": "Чем отличается Queue от Deque?",
            "answerRu": "Queue в Java — это линейная структура данных, хранящая элементы с вставкой только в конец и удалением с начала. Deque, или двусторонняя очередь, расширяет это, позволяя вставку и удаление с обоих концов. Queue следует порядку FIFO (первым пришел, первым ушел) и может быть реализован через массивы или связанные списки. Deque, реализованный с помощью круговых массивов или двусвязных списков, поддерживает гибкие операции, такие как стек или двустороннее извлечение. Queue подходит для последовательных задач вроде списков ожидания, а Deque — для случаев с двусторонним доступом.",
            "category": "Collections",
            "level": "Junior"
        },
        {
            "id": 206,
            "questionEn": "Differentiate between HashSet and TreeSet.",
            "answerEn": "HashSet in Java is an unordered collection implemented by the HashSet class, using a hash table for storage. TreeSet, implemented by the TreeSet class, maintains elements in a sorted order based on natural ordering or a custom comparator. HashSet permits one null element, while TreeSet rejects null elements due to its sorting requirement. HashSet offers faster performance for basic operations like add and remove, whereas TreeSet is slower due to tree maintenance. These differences make HashSet ideal for quick lookups and TreeSet for sorted, unique collections.",
            "questionRu": "Чем отличается HashSet от TreeSet?",
            "answerRu": "HashSet в Java — это неупорядоченная коллекция, реализованная классом HashSet с использованием хэш-таблицы для хранения. TreeSet, реализованный классом TreeSet, поддерживает элементы в отсортированном порядке на основе естественного порядка или пользовательского компаратора. HashSet допускает один null-элемент, тогда как TreeSet отклоняет null из-за требований сортировки. HashSet обеспечивает более высокую скорость для операций вроде add и remove, а TreeSet медленнее из-за поддержки дерева. Эти различия делают HashSet подходящим для быстрых поисков, а TreeSet — для сортированных уникальных коллекций.",
            "category": "Collections",
            "level": "Junior"
        }
];
// const categories = [
//     "Java Core",
//     "Object-Oriented Programming (OOP)", // Переименовано с русского
//     "JVM, JDK, JRE",
//     "JVM Memory Management & Garbage Collection", // Переименовано с русского
//     "Exceptions & Error Handling", // Переименовано с русского
//     "Collections",
//     "Multithreading & Concurrency", // Переименовано с русского
//     "Input/Output Streams (IO/NIO)", // Переименовано с русского
//     "Java 8+ (Lambdas, Streams, Functional Interfaces)",
//     "JDBC & Databases", // Переименовано с русского
//     "JPA & Hibernate (ORM)",
//     "SQL & NoSQL Databases", // Переименовано с русского
//     "Design Patterns", // Переименовано с русского
//     "Spring Framework",
//     "Apache Kafka",
//     "REST API & Web Services", // Переименовано с русского
//     "Testing (JUnit, Mockito, TDD)", // Переименовано с русского
//     "Build Systems & Dependency Management (Maven, Gradle)", // Переименовано с русского
//     "Git & Version Control Systems", // Переименовано с русского
//     "Docker & Containerization", // Переименовано с русского
//     "Architecture & Application Design", // Переименовано с русского
//     "Algorithms & Data Structures", // Переименовано с русского
//     "All Questions" // Переименовано с русского
// ];
